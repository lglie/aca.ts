
// Convert the items of the array list to the boolean form of returning format
const $ArrayTrue = (arrayItem: string[]) =>
  arrayItem.reduce((_: any, v) => ((_[v] = true), _), {})

// Process the returned database record
function $RtnSelect(table: string, rtnCols: any, select?: any): any {
  if (Array.isArray(rtnCols)) {
    const rtn: any = []
    for (const v of rtnCols) rtn.push($RtnSelect(table, v, select))
    return rtn
  } else {
    const rtn: any = {}
    const scalarCols = $Att[table].scalarColumns

    const jsName = (name: string) => {
      rtn[name] = rtnCols[name]
      if (typeof rtn[name] === 'string') rtn[name] = rtn[name].trim()
      switch ($Att[table].columns[name].type) {
        case 'int':
        case 'bigint':
          rtn[name] = (rtn[name] || rtn[name] === 0) ? Math.round(Number(rtn[name])) : undefined
          break
        case 'float':
          rtn[name] = (rtn[name] || rtn[name] === 0) ? Number(rtn[name]) : undefined
      }
    }

    const scalarRtn = (selectCols: any) => {
      if (Array.isArray(selectCols)) {
        for (const v of selectCols) {
          if (v !== '*') jsName(v)
        }
      } else
        for (const k in selectCols) {
          if (k !== '*') jsName(k)
        }
    }

    if (Object.keys(rtnCols).length) {
      if (select && Object.keys(select).length) {
        if (Object.keys(select).includes('*')) scalarRtn([...scalarCols, ...Object.keys(select)])
        else scalarRtn(select)
      } // Return all scalar fields of the scalar
      else scalarRtn(scalarCols)

      return rtn
    } else return rtnCols
  }
}
function isValidDate(value: any) {
  const date = new Date(value)
  return !isNaN(date.getTime())
}
const $Queries = function (trx: any, sql: string[] = []) {
  const trxQuery = async (clause: any) => {
    sql.push(clause.toString())
    return await clause
  }

  function argsValidate(
    table: string,
    args: any,
    query: 'select' | 'insert' | 'update' | 'delete',
    trx: any
  ): any {
    const records = Array.isArray(args) ? args : [args]
    const AttCols: any = $Att[table].columns
    // Used to store added or modified columns
    const addedColumns: any = records.map((v) => ({}))
    for (let i = 0; i < records.length; i++) {
      for (const AttCol in AttCols) {
        if (AttCols[AttCol].relation) continue
        if (records[i][AttCol] !== undefined && records[i][AttCol] !== null) {
          // Determine jsType
          if (
            AttCols[AttCol].type === 'enum'
              ? !(<any>$Enum[<$EnumKeys>AttCols[AttCol].jsType]).includes(records[i][AttCol])
              : AttCols[AttCol].type === 'Date'
              ? !isValidDate(records[i][AttCol])
              : typeof records[i][AttCol] !== AttCols[AttCol].jsType
          ) {
            throw `table "${$Att[table].dbName}" field "${AttCol}" data type mismatch`
          }
          // If it is a number type and an int type
          if (AttCols[AttCol].type === 'int' && typeof records[i][AttCol] === 'number') {
            records[i][AttCol] = <any>Math.round(Number(records[i][AttCol]))
            // Determine if the data exceeds the limit(check constraint)
          } else if (AttCols[AttCol].type === 'object' && typeof records[i][AttCol] === 'object') {
            records[i][AttCol] = <any>JSON.stringify(records[i][AttCol])
          }
        } else {
          // When inserting, if it ia a nullable foreign key, the value is set to null
          if (query === 'insert') {
            if (
              AttCols[AttCol].type === 'id' &&
              !$Att[table].foreignKeys.includes(AttCol) &&
              (AttCols[AttCol].dbType === 'uuid' || AttCols[AttCol].dbType === 'cuid')
            ) {
              addedColumns[i][AttCol] = { uuid: uuidv4(), cuid: cuid() }[AttCols[AttCol].dbType]
            } else if ('required' !== AttCols[AttCol].optional) {
              if ($Att[table].foreignKeys.includes(AttCol)) addedColumns[i][AttCol] = null
            } else {
              throw `"${$Att[table].dbName}": missing required fieldmissing required field: "${AttCol}"`
            }
          }
        }
      }
      if (query === 'update') {
        if ($Att[table].updatedAtColumns && $Att[table].updatedAtColumns.length) {
          for (const AttCol of $Att[table].updatedAtColumns) {
            addedColumns[i][AttCol] = trx.raw('CURRENT_TIMESTAMP')
          }
        }
      }
    }

    const rtns = addedColumns.map((v: object, i: number) => ({
      ...records[i],
      ...v
    }))

    return Array.isArray(args) ? rtns : rtns[0]
  }

  const trxWhere = (Kx: any, table: string, where: any, logic: $WhereLogic = 'AND') => {
    const operator: any = {
      eq: '=',
      lt: '<',
      gt: '>',
      lte: '<=',
      gte: '>=',
      like: 'like'
    }

    const whereLogic = {
      AND: 'where',
      OR: 'orWhere',
      NOT: 'whereNot'
    }[logic]

    for (const key in where) {
      const AttCol = $Att[table].columns[key]
      // is relational field
      if (
        AttCol?.relation &&
        where[key] &&
        typeof where[key] === 'object' &&
        Object.keys(where[key]).length
      ) {
        // Determine if it is a primary key table or a foreign key table
        switch (AttCol.relation.kind) {
          case 'primary':
            // Find the reference field of all records of primary key table that meet the conditions
            if (AttCol.relation.toOne) {
              Kx[whereLogic + 'In'](
                AttCol.relation.references.map(
                  (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                ),
                trxWhere(trx($Att[AttCol.type].dbName), AttCol.type, where[key]).select(
                  AttCol.relation.keys.map(
                    (v) => `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[v].dbName}`
                  )
                )
              )
            } else {
              for (const k in where[key])
                Kx[`where${k === 'some' ? '' : 'Not'}In`](
                  AttCol.relation.references.map(
                    (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                  ),
                  trxWhere(
                    trx($Att[table].dbName)
                      .select(
                        AttCol.relation.references.map(
                          (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                        )
                      )
                      .innerJoin($Att[AttCol.type].dbName, function (this: any) {
                        for (
                          let i = 0, r = AttCol.relation.references, f = AttCol.relation.keys;
                          i < r.length;
                          i++
                        ) {
                          this.andOn(
                            `${$Att[table].dbName}.${$Att[table].columns[r[i]].dbName}`,
                            '=',
                            `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[f[i]].dbName}`
                          )
                        }
                      }),
                    AttCol.type,
                    where[key][k],
                    k === 'every' ? 'NOT' : undefined
                  )
                )
            }
            break
          case 'foreign':
            Kx[whereLogic + 'In'](
              AttCol.relation.keys.map(
                (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
              ),
              trxWhere(trx($Att[AttCol.type].dbName), AttCol.type, where[key]).select(
                AttCol.relation.references.map(
                  (v) => `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[v].dbName}`
                )
              )
            )
            break
          case 'many':
            for (const k in where[key]) {
              Kx[`where${k === 'some' ? '' : 'Not'}In`](
                $Att[table].id.map((v: string) => `${$Att[table].dbName}.${v}`),
                trxWhere(
                  trx(AttCol.relation.mapTable)
                    .select(
                      $Att[table].id.map(
                        (v: string) => `${AttCol.relation.mapTable}.${$Att[table].dbName}_${v}`
                      )
                    )
                    .join($Att[AttCol.type].dbName, function (this: any) {
                      for (const v of $Att[AttCol.type].id) {
                        this.andOn(
                          `${AttCol.relation.mapTable}.${$Att[AttCol.type].dbName}_${v}`,
                          '=',
                          `${$Att[AttCol.type].dbName}.${v}`
                        )
                      }
                    }),
                  AttCol.type,
                  where[key][k],
                  k === 'every' ? 'NOT' : undefined
                )
              )
            }
        }
      } else if (['AND', 'OR', 'NOT'].includes(key)) {
        switch (key) {
          case 'AND':
            if (Array.isArray(where[key])) {
              Kx = Kx['where']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v, <$WhereLogic>key)
                }
              })
            } else if (where[key]) {
              Kx = Kx['where']((builder) => {
                trxWhere(builder, table, where[key], <$WhereLogic>key)
              })
            }
            break
          case 'OR':
            if (Array.isArray(where[key])) {
              Kx = Kx['orWhere']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v)
                }
              })
            } else if (where[key]) {
              Kx = Kx['orWhere']((builder) => {
                trxWhere(builder, table, where[key])
              })
            }
            break
          case 'NOT':
            if (Array.isArray(where[key])) {
              Kx = Kx['whereNot']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v)
                }
              })
            } else if (where[key]) {
              Kx = Kx['whereNot']((builder) => {
                trxWhere(builder, table, where[key])
              })
            }
            break
        }
      } else {
        let newKey
        if (key.split(',').length > 1) {
          newKey = key.split(',').map((v) => `${$Att[table].dbName}.${v}`)
        } else {
          newKey = `${$Att[table].dbName}.${key}`
        }
        if (where[key] && typeof where[key] === 'object') {
          Kx = Kx[whereLogic]((builder) => {
            switchScalarCol(builder, where[key], newKey)
          })
        } else {
          Kx =
            where[key] === null
              ? Kx[whereLogic + 'Null'](newKey)
              : Kx[whereLogic](newKey, where[key])
        }
      }
    }

    async function switchScalarCol(Kx, scalarWhere, newKey) {
      const operators = Object.keys(scalarWhere)
      for (const op of operators) {
        let newOp = op,
          newWhere = scalarWhere[op]
        switch (op) {
          case 'contains':
          case 'startsWith':
          case 'endsWith':
            newWhere = `${op === 'startsWith' ? '' : '%'}${newWhere}${op === 'endsWith' ? '' : '%'}`
            newOp = 'like'
          case 'eq':
            if (newWhere === null) {
              Kx = Kx[whereLogic + 'Null'](newKey)
              break
            }
          case 'lt':
          case 'gt':
          case 'lte':
          case 'gte':
          case 'like':
            Kx = Kx[whereLogic](newKey, operator[newOp], newWhere)
            break
          case 'in':
            Kx = Kx[whereLogic + 'In'](
              newKey,
              newWhere.map((v: any) => v)
            )
            break
          case 'between':
            Kx = Kx[whereLogic + 'Between'](newKey, newWhere)
            break
          case 'OR':
            if (Array.isArray(newWhere)) {
              Kx = Kx['orWhere']((builder) => {
                for (const v of newWhere) {
                  switchScalarCol(builder, v, newKey)
                }
              })
            } else if (newWhere) {
              Kx = Kx['orWhere']((builder) => {
                switchScalarCol(builder, newWhere, newKey)
              })
            }
            break
          case 'AND':
            if (Array.isArray(newWhere)) {
              Kx = Kx['where']((builder) => {
                for (const v of newWhere) {
                  switchScalarCol(builder, v, newKey)
                }
              })
            } else if (newWhere) {
              Kx = Kx['where']((builder) => {
                switchScalarCol(builder, newWhere, newKey)
              })
            }
            break
          case 'not':
            if (newWhere !== null && typeof newWhere === 'object') {
              if (Array.isArray(newWhere)) {
                Kx = Kx['whereNot']((builder) => {
                  for (const v of newWhere) {
                    switchScalarCol(builder, v, newKey)
                  }
                })
              } else if (newWhere) {
                Kx = Kx['whereNot']((builder) => {
                  switchScalarCol(builder, newWhere, newKey)
                })
              }
            } else {
              newWhere === null
                ? (Kx =
                    Kx[whereLogic === 'whereNot' ? 'whereNull' : whereLogic + 'NotNull'](newKey))
                : (Kx = Kx[whereLogic === 'whereNot' ? 'where' : whereLogic + 'Not'](
                    newKey,
                    newWhere
                  ))
            }
        }
      }
    }

    return Kx
  }

  // Seperate relation fields into arrays: [scalar,primary,foreign,many]
  const splitCols = (table: string, cols: { [x: string]: any }) =>
    Object.keys(cols).reduce(
      (_: any, k: any) => (
        (_[
          $Att[table].columns[k]?.relation
            ? { primary: 1, foreign: 2, many: 3 }[
                <'primary' | 'foreign' | 'many'>$Att[table].columns[k].relation.kind
              ]
            : 0
        ][k] = cols[k]),
        _
      ),
      [{}, {}, {}, {}]
    )

  // Convert columns into database columns
  const dbCols = (table: string, cols: { [x: string]: any }): any => {
    if (Array.isArray(cols)) {
      const rtn: any = []
      for (const v of cols) rtn.push(dbCols(table, v))
      return rtn
    } else {
      const rtn: any = {}
      for (const k in cols) {
        if ($Att[table].columns[k]) {
          rtn[$Att[table].columns[k].dbName] = cols[k]
        }
      }
      return rtn
    }
  }

  // Update arithmetric operator, only process scalar fields, and add where conditions when calling
  const updateOperator = (table: string, data: { [x: string]: any }) => {
    const Kx = Object.keys(data || {}).reduce((_: any, v) => {
      const col = $Att[table].columns[v]
      if (col.jsType === 'number' && typeof data[v] === 'object') {
        const [[oper, val]] = Object.entries(data[v])
        _ = _[oper](col.dbName, val)
        delete data[v]
      }
      return _
    }, trx($Att[table].dbName))

    return data ? Kx.update(dbCols(table, data)) : Kx
  }

  // Find the unique value of a record
  const recordUnique = (table: string | number, record: { [x: string]: any }) => {
    let uniqueWhere: any = {}
    for (const unique of $Att[table].uniques) {
      if (Array.isArray(unique)) {
        for (const item of unique) {
          if (record[item]) {
            uniqueWhere[item] = record[item]
          } else {
            break
          }
        }
        return uniqueWhere
      } else {
        if (record[unique]) {
          return { [unique]: record[unique] }
        }
      }
    }
  }

  return {
    async finder(table: string, { where = {}, distinct, orderBy, limit, offset, select = { '*': true } }: any = {}) {
      // Process where condition
      let Kx = trx.from(`${$Att[table].dbName} as ${$Att[table].dbName}`)
      if (typeof limit === 'number') Kx = Kx.limit(limit)
      if (typeof offset === 'number') Kx = Kx.offset(offset)
      if (typeof orderBy === 'object') {
        orderBy = Array.isArray(orderBy) ? orderBy : [orderBy]
        Kx = Kx.orderBy(
          orderBy.map((obj: { [s: string]: unknown } | ArrayLike<unknown>) => {
            const [[k, v]] = Object.entries(obj)
            return { column: k, order: v }
          })
        )
      }
      if (distinct) Kx = Kx.distinct(Array.isArray(distinct) ? distinct.toString() : distinct)

      const wKnex = trxWhere(Kx, table, where)
      let returning = []
      leftJoin(table, select)
      // Process incoming parameters
      sql.push(wKnex.select(returning).toString())
      let result = await wKnex.select(returning)
      const data = returningSelect(table, select, result)
      return data
      function returningSelect(
        table: string,
        select: Record<string, any>,
        rows: any[],
        fieldKey?: string,
        data?: any[]
      ) {
        const AttCols = $Att[table].columns
        if (Object.keys(select).length) {
          let [scalarCols, relationCols] = Object.keys(select).reduce(
            (_: any, v: string) => {
              if (typeof select[v] === 'object') _[1][v] = select[v]
              else if (select[v] === true) _[0][v] = select[v]
              return _
            },
            [{}, {}]
          )
          if (scalarCols['*']) {
            scalarCols = $Att[table].scalarColumns.reduce((attr, v) => {
              return { ...attr, [v]: true }
            }, {})
          }
          if ($Att[table].id) {
            for (const v of $Att[table].id) {
              if (!Object.keys(scalarCols).includes(v)) {
                scalarCols[v] = true
              }
            }
          }
          const item = {}
          for (const val of rows) {
            let dataKey
            if ($Att[table].id) {
              dataKey = $Att[table].id.map((v) => (fieldKey ? val[`${fieldKey}.${v}`] : val[v])).join('_')
            } else {
              dataKey = Object.keys(val).map(v => (fieldKey ? val[`${fieldKey}.${v}`] : val[v])).join('_')
            }
            if (dataKey && !item[dataKey]) {
              item[dataKey] = $RtnSelect(
                table,
                Object.keys(scalarCols).reduce((attrs, v) => {
                  return {
                    ...attrs,
                    [v]: fieldKey ? val[`${fieldKey}.${v}`] || undefined : val[v] || undefined
                  }
                }, {}),
                select
              )
              for (const key in relationCols) {
                item[dataKey][key] = returningSelect(
                  AttCols[key].type,
                  select[key].select ?? select[key],
                  rows.filter(
                    (v) => $Att[table].id.map((vv) => (fieldKey ? v[`${fieldKey}.${vv}`] : v[vv])).join('_') === dataKey
                  ),
                  fieldKey ? `${fieldKey}.${key}` : key
                )
                if (AttCols[key].relation.kind === 'foreign' || AttCols[key].relation.toOne) {
                  item[dataKey][key] = item[dataKey][key][0]
                }
              }
            }
          }
          data = Object.values(item)

          return data
        }
      }
      function leftJoin(table: string, select: Record<string, any>, fieldKey?: string) {
        const AttCols = $Att[table].columns
        if (Object.keys(select).length) {
          let [scalarCols, relationCols] = Object.keys(select).reduce(
            (_: any, v: string) => {
              if (typeof select[v] === 'object') _[1][v] = select[v]
              else if (select[v] === true) _[0][v] = v
              return _
            },
            [{}, {}]
          )
          if (scalarCols['*']) {
            scalarCols = $Att[table].scalarColumns.reduce((attr, v) => {
              return { ...attr, [v]: v }
            }, {})
          }
          if ($Att[table].id) {
            for (const v of $Att[table].id) {
              if (!Object.keys(scalarCols).includes(v)) {
                scalarCols[v] = v
              }
            }
          }
          returning = returning.concat(
            Object.values(scalarCols).map((v: any) => {
              if (fieldKey) {
                return `${fieldKey.replaceAll('.', '->')}.${AttCols[v].dbName} as ${fieldKey}.${v}`
              } else {
                return `${$Att[table].dbName}.${AttCols[v].dbName}`
              }
            })
          )
          for (const key in relationCols) {
            const where: any = relationCols[key].where ?? {}
            let pKeys: string[], fKeys: string[], relIds, joinRaw: string
            let alias = fieldKey ? `${fieldKey}.${key}` : key
            alias = alias.replaceAll('.', '->')
            let pAlias = fieldKey ? fieldKey : $Att[table].dbName
            pAlias = pAlias.replaceAll('.', '->')
            switch (AttCols[key].relation.kind) {
              case 'primary':
                const rel = $Att[AttCols[key].type].columns[AttCols[key].relation.relColumn].relation
                pKeys = rel.references
                fKeys = rel.keys
                joinRaw = `left outer join "${$Att[AttCols[key].type].dbName}" as "${alias}" on ${fKeys
                  .map(
                    (v, index) =>
                      `"${alias}"."${$Att[AttCols[key].type].columns[v].dbName}" = "${pAlias}"."${
                        AttCols[pKeys[index]].dbName
                      }"`
                  )
                  .join(' and ')} `
                break
              case 'foreign':
                pKeys = AttCols[key].relation.references
                fKeys = AttCols[key].relation.keys

                joinRaw = `left outer join "${$Att[AttCols[key].type].dbName}" as "${alias}" on ${pKeys
                  .map(
                    (v, index) =>
                      `"${alias}"."${$Att[AttCols[key].type].columns[v].dbName}" = "${pAlias}"."${
                        AttCols[fKeys[index]].dbName
                      }"`
                  )
                  .join(' and ')} `
                break
              case 'many':
                const id = $Att[AttCols[key].type].id
                const tableId = $Att[table].id.map((v2: any) => `${$Att[table].dbName}_${v2}`)
                wKnex.leftOuterJoin(`${AttCols[key].relation.mapTable}`, function () {
                  const _this = this
                  tableId.forEach((v, index) => {
                    _this.on(
                      `${AttCols[key].relation.mapTable}.${v}`,
                      '=',
                      `${pAlias}.${AttCols[$Att[table].id[index]].dbName}`
                    )
                  })
                })
                joinRaw = `left outer join "${$Att[AttCols[key].type].dbName}" as "${alias}" on ${$Att[
                  AttCols[key].type
                ].id
                  .map(
                    (v, index) =>
                      `"${alias}"."${$Att[AttCols[key].type].columns[v].dbName}" = "${
                        AttCols[key].relation.mapTable
                      }"."${$Att[AttCols[key].type].dbName}_${v}"`
                  )
                  .join(' and ')} `
                break
            }
            if (Object.keys(where).length) {
              joinRaw += `and (${$Att[AttCols[key].type].id
                .map((v) => `"${alias}"."${$Att[AttCols[key].type].columns[v].dbName}"`)
                .join(',')}) in (${trxWhere(
                trx.from(`${$Att[AttCols[key].type].dbName}`),
                AttCols[key].type,
                where
              ).select(
                $Att[AttCols[key].type].id.map(
                  (v) => `${$Att[AttCols[key].type].dbName}.${$Att[AttCols[key].type].columns[v].dbName}`
                )
              )})`
            }
            wKnex.joinRaw(joinRaw)

            leftJoin(AttCols[key].type, select[key].select ?? select[key], fieldKey ? `${fieldKey}.${key}` : key)
          }
        }
      }
    },

    async insert(table: string, args: any) {
      let scalarRtn: Array<any>

      if (Array.isArray(args.data)) {
        // is an array, filter each record in the array, and seperate out if there is a relational field
        
        const scalarRecords = []
        const relationRecords = []
        for (const val of args.data){
          const [scalarCols, primaryCols, foreignCols, manyCols] = splitCols(table, val)
          if (Object.keys(foreignCols).length) {
            const relColumns: any = Object.entries(foreignCols)
            // If there exists a foreign key field, you must create a primary key table to obtain the referenced field value
            for (const [k, v] of relColumns) {
              const AttCol = $Att[table].columns[k]
              const { references, keys } = AttCol.relation
              if (v.connectOrInsert) {
                // Find if the connection exists
                let pTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                    .select('*')
                )
  
                ;[pTable] = pTable.length
                  ? pTable
                  : await this.insert(AttCol.type, {
                      data: v.connectOrInsert.insert
                    })
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
              if (v.connect) {
                // Find the connection
                let [pTable] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
                )
                if (!pTable)
                  throw `table found "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                    v.connect
                  )}" does not exist`
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
              if (v.insert) {
                let [pTable] = await this.insert(AttCol.type, {
                  data: v.insert
                })
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
            }
          }
          if (Object.keys(scalarCols).length) {
            scalarRecords.push(scalarCols)
          }
          
          if (Object.keys(primaryCols).length) {
            relationRecords.push(primaryCols)
          }
          if (Object.keys(manyCols).length) {
            relationRecords.push(manyCols)
          }
        }
        // Create pure scalar record
        if (scalarRecords.length) {
          scalarRtn = await trxQuery(
            trx($Att[table].dbName)
              .insert(dbCols(table, argsValidate(table, scalarRecords, 'insert', trx)))
              .returning('*')
          )
        } else {
          scalarRtn = []
        }

        if (relationRecords.length) {
          for (const record of relationRecords) {
            scalarRtn = scalarRtn.concat(
              await this.insert(table, {
                data: record,
                select: args.select
              })
            )
          }
        }

        return scalarRtn
      } else {
        // is single record, seperate out scalar fields, relational(primary key table, foreign key table, many-to-many table) fields
        const [scalarCols, primaryCols, foreignCols, manyCols] = splitCols(table, args.data)

        // When there is a foreign key field, create its primary key table and get tje foreign key value
        if (Object.keys(foreignCols).length) {
          const relColumns: any = Object.entries(foreignCols)
          // If there exists a foreign key field, you must create a primary key table to obtain the referenced field value
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            if (v.connectOrInsert) {
              // Find if the connection exists
              let pTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                  .select('*')
              )

              ;[pTable] = pTable.length
                ? pTable
                : await this.insert(AttCol.type, {
                    data: v.connectOrInsert.insert
                  })
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
            if (v.connect) {
              // Find the connection
              let [pTable] = await trxQuery(
                trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
              )
              if (!pTable)
                throw `table found "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                  v.connect
                )}" does not exist`
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
            if (v.insert) {
              let [pTable] = await this.insert(AttCol.type, {
                data: v.insert
              })
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
          }
        }
        // Create this table and get the uniqur field for foreign key table to use
        scalarRtn = await trxQuery(
          trx($Att[table].dbName)
            .insert(dbCols(table, argsValidate(table, scalarCols, 'insert', trx)))
            .returning('*')
        )
        scalarRtn = $RtnSelect(table, scalarRtn, { '*': true })
        // Create all foreign key tables and apply the unique key of this table to the corresponding table
        if (Object.keys(primaryCols).length) {
          const relColumns: any = Object.entries(primaryCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            const relationForeign: any = {}
            for (let i = 0; i < keys.length; i++)
              relationForeign[keys[i]] = scalarRtn[0][references[i]]
            // ont-to-one relationship
            if (AttCol.relation?.toOne) {
              if (v.connectOrInsert) {
                let rTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
                if (!rTable.length)
                  await this.insert(AttCol.type, {
                    data: {
                      ...v.connectOrInsert.insert,
                      ...relationForeign
                    }
                  })
              }
              if (v.connect) {
                await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: { ...v.insert, ...relationForeign }
                })
              }
            } else {
              // one-to-many relationship
              if (v.connectOrInsert) {
                if (!Array.isArray(v.connectOrInsert)) v.connectOrInsert = [v.connectOrInsert]
                for (const val of v.connectOrInsert) {
                  let rTable = await trxQuery(
                    trx($Att[AttCol.type].dbName)
                      .where(dbCols(AttCol.type, val.connect))
                      .update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                      .returning('*')
                  )
                  if (!rTable.length)
                    await this.insert(AttCol.type, {
                      data: {
                        ...val.insert,
                        ...relationForeign
                      }
                    })
                }
              }
              if (v.connect) {
                if (!Array.isArray(v.connect)) v.connect = [v.connect]
                await trxQuery(
                  trx.raw(
                    v.connect
                      .reduce(
                        (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                        trx($Att[AttCol.type].dbName).update(
                          dbCols(
                            AttCol.type,
                            argsValidate(AttCol.type, relationForeign, 'update', trx)
                          )
                        )
                      )
                      .toString()
                  )
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: Array.isArray(v.insert)
                    ? v.insert.map((val: any) => ({
                        ...val,
                        ...relationForeign
                      }))
                    : { ...v.insert, ...relationForeign }
                })
              }
            }
          }
        }
        // Create many-to-many relational field
        if (Object.keys(manyCols).length) {
          // Mapping table id
          const mapTabelId = $Att[table].id.reduce(
            (_: any, v: string | number) => (
              (_[`${$Att[table].dbName}_${v}`] = scalarRtn[0][v]), _
            ),
            {}
          )
          const relColumns: any = Object.entries(manyCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            // id of this table
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              // Query the id of each record in the relational table
              for (const item of items) {
                let [relMapTableId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(item).select($Att[AttCol.type].id)
                )

                relMapTableId = Object.keys(relMapTableId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relMapTableId[v]), _),
                  {}
                )
                // upsert data to the mapping table
                const mapRecord = { ...mapTabelId, ...relMapTableId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              const ret = await this.insert(AttCol.type, {
                data: v.insert,
                select: $ArrayTrue($Att[AttCol.type].id)
              })
              let relMapTableIds = ret.map((record) =>
                Object.keys(record).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = record[v]), _),
                  {}
                )
              )

              await trxQuery(
                trx(AttCol.relation.mapTable).insert(
                  relMapTableIds.map((v) => ({
                    ...mapTabelId,
                    ...v
                  }))
                )
              )
            }
          }
        }

        return scalarRtn
      }
    },

    async upsert(table: string, args: any) {
      const contained = await trxQuery(trx($Att[table].dbName).where(args.where).select('*'))

      return contained.length
        ? args.update
          ? await this.update(table, {
              where: args.where,
              data: args.update,
              select: args.select
            })
          : await this.finder(table, {
              where: args.where,
              select: args.select
            })
        : await this.insert(table, {
            data: args.insert,
            select: args.select
          })
    },

    async update(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length) throw `where cannot be empty`
      // Find the record and return if not exist
      if (!args.data) throw `Modified table "${table}" does not have incoming data`
      const trxTmp = await trxQuery(trx($Att[table].dbName).where(args.where).select('*'))
      if (!trxTmp.length)
        throw `table "${$Att[table].dbName}" has no record for the condition: "${args.where}"`

      const [scalarColumns, primaryColumns, foreignColumns, manyColumns] = splitCols(
        table,
        args.data
      )

      if (Object.keys(foreignColumns).length) {
        const relColumns: any = Object.entries(foreignColumns)

        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          // Use foreign keys as where condition
          let foreignWhere: any = {},
            currTable: any
          for (let i = 0; i < references.length; i++) {
            foreignWhere[references[i]] =
              args.where[keys[i]] || (!currTable && ([currTable] = trxTmp), currTable[keys[i]])
          }
          if (v.connectOrInsert) {
            // Find if the connection exists
            let pTable = await trxQuery(
              trx($Att[AttCol.type].dbName)
                .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                .select('*')
            )

            ;[pTable] = pTable.length
              ? pTable
              : await this.insert(AttCol.type, {
                  data: v.connectOrInsert.insert
                })
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.connect) {
            // Find the connection
            let [pTable] = await trxQuery(
              trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
            )

            if (!pTable)
              throw `query table "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                v.connect
              )}" does not exist`
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.insert) {
            let [pTable] = await this.insert(AttCol.type, {
              data: v['insert']
            })
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.upsert) {
            await this.upsert(AttCol.type, {
              ...v.upsert,
              where: foreignWhere
            })
          }
          if (v.update) {
            await this.update(AttCol.type, {
              where: foreignWhere,
              data: v.update
            })
          }
          if (v.delete === true) {
            await trxQuery(
              trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, foreignWhere)).del()
            )
          }
          if (v.disconnect === true) {
            await keys.reduce((_: any, v: string) => ((_[v] = null), _), scalarColumns)
          }
        }
      }

      // Modify this table
      let tableRtn
      if (Object.keys(scalarColumns).length) {
        const trxTmp = await trxQuery(
          trx($Att[table].dbName)
            .where(dbCols(table, args.where))
            .update(dbCols(table, argsValidate(table, scalarColumns, 'update', trx)))
            .returning('*')
        )
        tableRtn = trxTmp
      } else {
        tableRtn = await trxWhere(
          trx($Att[table].dbName).select(args.select ? Object.keys(args.select) : '*'),
          table,
          args?.where
        )
      }
      tableRtn = $RtnSelect(table, tableRtn, { '*': true })

      if (Object.keys(primaryColumns).length) {
        const relColumns: any = Object.entries(primaryColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          const relationForeign: any = {}
          for (let i = 0; i < keys.length; i++)
            relationForeign[keys[i]] = tableRtn[0][references[i]]
          if (AttCol.relation?.toOne) {
            if (v.connectOrInsert) {
              let rTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                  .update(
                    dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                  )
                  .returning('*')
              )

              if (!rTable.length)
                await this.insert(AttCol.type, {
                  data: {
                    ...v.connectOrInsert.insert,
                    ...relationForeign
                  }
                })
            }
            if (v.connect) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connect))
                  .update(
                    dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                  )
                  .returning('*')
              )
            }
            if (v.insert) {
              await this.insert(AttCol.type, {
                data: {
                  ...v.insert,
                  ...relationForeign
                }
              })
            }
            if (v.upsert) {
              await this.upsert(AttCol.type, {
                ...v.upsert,
                where: relationForeign
              })
            }
            if (v.update) {
              await this.update(AttCol.type, {
                where: relationForeign,
                data: v.update
              })
            }
            if (v.delete === true) {
              await trxQuery(
                trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, relationForeign)).del()
              )
            }
            if (v.disconnect === true) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, relationForeign))
                  .update(
                    dbCols(
                      AttCol.type,
                      argsValidate(
                        AttCol.type,
                        keys.reduce((_: any, v: any) => ((_[v] = null), _), {}),
                        'update',
                        trx
                      )
                    )
                  )
              )
            }
          } else {
            // one-to-many relationship
            if (v.disconnect) {
              await trxQuery(
                trx.raw(
                  trxWhere(
                    v.disconnect.reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(
                            AttCol.type,
                            keys.reduce((_: any, v: any) => ((_[v] = null), _), {}),
                            'update',
                            trx
                          )
                        )
                      )
                    ),
                    AttCol.type,
                    relationForeign
                  ).toString()
                )
              )
            }
            if (v.deleteMany) {
              await trxQuery(
                trx.raw(
                  trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, {
                    ...v.deleteMany,
                    ...relationForeign
                  }).toString()
                )
              )
            }

            if (v.set) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, relationForeign))
                  .update(
                    dbCols(
                      AttCol.type,
                      keys.reduce((_: any, v: any) => ((_[v] = null), _), {})
                    )
                  )
              )
              if (!Array.isArray(v.set)) v.set = [v.set]
              await trxQuery(
                trx.raw(
                  v.set
                    .reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                    )
                    .toString()
                )
              )
            }
            if (v.connectOrInsert) {
              if (!Array.isArray(v.connectOrInsert)) v.connectOrInsert = [v.connectOrInsert]
              for (const val of v.connectOrInsert) {
                let rTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, val.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
                if (!rTable.length)
                  await this.insert(AttCol.type, {
                    data: {
                      ...val.insert,
                      ...relationForeign
                    }
                  })
              }
            }
            if (v.connect) {
              if (!Array.isArray(v.connect)) v.connect = [v.connect]
              await trxQuery(
                trx.raw(
                  v.connect
                    .reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                    )
                    .toString()
                )
              )
            }
            if (v.insert) {
              await this.insert(AttCol.type, {
                data: Array.isArray(v.insert)
                  ? v.insert.map((val: any) => ({
                      ...val,
                      ...relationForeign
                    }))
                  : { ...v.insert, ...relationForeign }
              })
            }
            if (v.upsert) {
              if (!Array.isArray(v.upsert)) v.upsert = [v.upsert]
              for (const val of v.upsert) {
                await this.upsert(AttCol.type, {
                  where: val.where,
                  update: val.update,
                  insert: { ...val.insert, ...relationForeign }
                })
              }
            }
            if (v.update) {
              if (!Array.isArray(v.update)) v.update = [v.update]
              for (const val of v.update) {
                await this.update(AttCol.type, {
                  where: {
                    ...val.where,
                    ...relationForeign
                  },
                  data: val.data
                })
              }
            }
            if (v.updateMany) {
              await trxQuery(
                trx.raw(
                  trxWhere(
                    trx($Att[AttCol.type].dbName).update(
                      dbCols(
                        AttCol.type,
                        argsValidate(AttCol.type, v.updateMany.data, 'update', trx)
                      )
                    ),
                    AttCol.type,
                    {
                      ...v.updateMany.where,
                      ...relationForeign
                    }
                  ).toString()
                )
              )
            }
            if (v.delete) {
              if (!Array.isArray(v.delete)) v.delete = [v.delete]
              for (const val of v.delete) {
                await trxQuery(
                  trx.raw(
                    trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, {
                      ...val,
                      ...relationForeign
                    }).toString()
                  )
                )
              }
            }
          }
        }
      }
      // many-to-many relationship
      if (Object.keys(manyColumns).length) {
        const relColumns: any = Object.entries(manyColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          // this table id
          let tableId
          if (args.where[$Att[table].id.join('_')]) {
            tableId = args.where
          } else {
            tableId = (
              await trxQuery(trx($Att[table].dbName).where(args.where).select($Att[table].id))
            )[0]
          }
          // id of mapping table
          let mapTableId: any = {}
          for (const k in tableId) {
            mapTableId[`${$Att[table].dbName}_${k}`] = tableId[k]
          }
          // ids of relational tables
          const trxTmp = await trxQuery(trx(AttCol.relation.mapTable).where(mapTableId).select('*'))
          const relTableIds = trxTmp.map((v: { [x: string]: any }) => {
            $Att[AttCol.type].id.reduce(
              (_: { [x: string]: any }, v2: string | number) => (
                (_[v2] = v[`${$Att[AttCol.type].dbName}_${v2}`]), _
              ),
              {}
            )
          })

          if (v.set) {
            const updateSet = async (record: { [x: string]: any }) => {
              // If the record has only 1 item, is unique, and the relational table has other required fields, it is considered to be connect
              // If the record has only 1 item, is unique, and the relational table does not havr other required fields, it is considered to be upsert
              if (
                Object.keys(record).length === 1 &&
                $Att[AttCol.type].uniques.some(
                  (v: any[]) => record[Array.isArray(v) ? v.join('_') : v]
                )
              ) {
                const columns = $Att[AttCol.type].columns
                let requiredItem: any = []
                $Att[AttCol.type].uniques.some((v: any) => {
                  const items = Array.isArray(v) ? v : [v]
                  if (record[items.join('_')]) {
                    requiredItem = Object.keys(columns).filter((v) =>
                      items.includes(v) ? false : 'required' === columns[v].optional
                    )
                    return true
                  } else return false
                })

                return requiredItem.length
                  ? await trxWhere(
                      trx($Att[AttCol.type].dbName).select($Att[AttCol.type].id),
                      AttCol.type,
                      record
                    )
                  : // There is no required field, it may be a connection or a creation, you need to use upsert
                    await trxQuery(
                      trx($Att[AttCol.type].dbName)
                        .insert(argsValidate(AttCol.type, record, 'insert', trx))
                        .onConflict(Object.keys(record))
                        .ignore()
                        .returning($Att[AttCol.type].id)
                    )
              }
              // is to creat
              else
                return await this.insert(AttCol.type, {
                  data: record
                })
            }

            let relTableId: any[] = []
            const items = Array.isArray(v.set) ? v.set : [v.set]
            for (const item of items) relTableId = relTableId.concat(await updateSet(item))

            // Delete the old relationships in the mapping table and store the new relationships
            await trxQuery(trx(AttCol.relation.mapTable).where(mapTableId).del())

            await trxQuery(
              trx(AttCol.relation.mapTable).insert(
                relTableId.map((v2) =>
                  Object.assign(
                    Object.keys(v2).reduce(
                      (_: any, v3) => ((_[`${$Att[AttCol.type].dbName}_${v3}`] = v2[v3]), _),
                      {}
                    ),
                    mapTableId
                  )
                )
              )
            )
          } else {
            let ids: any[] = []
            if (v.disconnect) {
              const items = Array.isArray(v.disconnect) ? v.disconnect : [v.disconnect]
              for (const v of items) {
                let [relId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(v).select($Att[AttCol.type].id)
                )
                relId = Object.keys(relId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _),
                  {}
                )
                const mapRecord = { ...mapTableId, ...relId }
                await trxQuery(trx(AttCol.relation.mapTable).where(mapRecord).del())
              }
            }
            if (v.deleteMany) {
              const where = trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, v.deleteMany)

              await trxWhere(where, AttCol.type, {
                // @ts-ignore
                [$Att[AttCol.type].id]: {
                  in: relTableIds.map((v: any) => Object.values(v))
                }
              })
            }
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              for (const v of items) {
                let [relId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(v).select($Att[AttCol.type].id)
                )
                relId = Object.keys(relId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _),
                  {}
                )
                const mapRecord = { ...mapTableId, ...relId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              // There may be a problem---------------------------------------------------------------------------------
              const updateInsert = async (record: any) =>
                await this.upsert(AttCol.type, {
                  where: recordUnique(AttCol.type, record),
                  insert: record
                })
              const items = Array.isArray(v.insert) ? v.insert : [v.insert]
              ids = await updateInsert(items)

              for (const v2 of ids) {
                const tableId = mapTableId
                for (const v3 of $Att[AttCol.type].id) {
                  tableId[`${$Att[AttCol.type].dbName}_${v3}`] = v2[v3]
                }
                await trxQuery(trx(AttCol.relation.mapTable).insert(tableId))
              }
            }
            if (v.upsert) {
              const items = Array.isArray(v.upsert) ? v.upsert : [v.upsert]
              for (const item of items) {
                await this.upsert(AttCol.type, item)
              }
            }
            if (v.update) {
              const items = Array.isArray(v.update) ? v.update : [v.update]
              for (const item of items) {
                await this.update(AttCol.type, item)
              }
            }
            if (v.updateMany) {
              await this.updateMany(AttCol.type, v.updateMany)
            }
            if (v.delete) {
              const items = Array.isArray(v.delete) ? v.delete : [v.delete]
              await items.reduce(
                (_: any, v) => trxWhere(_, AttCol.type, v, 'OR'),
                trx($Att[AttCol.type].dbName).del()
              )
              // Delete the corresponding records in the mapping table (subsequent improvement)
            }
          }
        }
      }

      return tableRtn
    },

    async updateMany(table: string, args: any) {
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(
        wKnex.update(argsValidate(table, dbCols(table, args.data), 'update', trx))
      )
    },

    async delete(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length) throw `where cannot be empty`
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(wKnex.del().returning('*'))
    },

    async deleteMany(table: string, args: any) {
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(wKnex.del())
      // return await trxQuery(trx($Att[table].dbName).where(args?.where).del())
    },

    async aggregate(table: string, args: any) {
      // if (!args?.select || args.select === '*') (<any>args).select = { count: '*' }
      const aggregates = [
        'count',
        'countDistinct',
        'sum',
        'sumDistinct',
        'avg',
        'avgDistinct',
        'max',
        'min'
      ]
      let Kx = trx.from(`${$Att[table].dbName} as ${$Att[table].dbName}`)
      if (typeof args.limit === 'number') Kx = Kx.limit(args.limit)
      if (typeof args.offset === 'number') Kx = Kx.offset(args.offset)
      const wKnex = trxWhere(Kx, table, args.where)
      for (const key in args) {
        if (
          aggregates.includes(key) &&
          args[key] &&
          typeof args[key] === 'object' &&
          Object.keys(args[key])
        ) {
          Object.keys(args[key]).forEach((k) => {
            if (args[key][k]) {
              if (k === '*' && ['count', 'countDistinct'].includes(key)) {
                wKnex[key](`* as ${key}->${k}`)
              } else if ($Att[table].columns[k]) {
                wKnex[key](`${$Att[table].columns[k].dbName} as ${key}->${k}`)
              }
            }
          })
        }
      }
      sql.push(wKnex.toString())
      let result = await wKnex
      result = result[0]
      const returning = {}
      for (const key in args) {
        if (
          aggregates.includes(key) &&
          args[key] &&
          typeof args[key] === 'object' &&
          Object.keys(args[key])
        ) {
          Object.keys(args[key]).forEach((k) => {
            if (args[key][k]) {
              if (returning[key]) {
                returning[key][k] = Number(result[`${key}->${k}`])
              } else {
                returning[key] = {
                  [k]: Number(result[`${key}->${k}`])
                }
              }
            }
          })
        }
      }
      return returning
    }
  }
}