
// Convert the items of the array list to the boolean form of returning format
const $ArrayTrue = (arrayItem: string[]) =>
  arrayItem.reduce((_: any, v) => ((_[v] = true), _), {})

// Process the returned database record
function $RtnSelect(table: string, rtnCols: any, select?: any): any {
  if (Array.isArray(rtnCols)) {
    const rtn: any = []
    for (const v of rtnCols) rtn.push($RtnSelect(table, v, select))
    return rtn
  } else {
    const rtn: any = {}
    const scalarCols = $Att[table].scalarColumns

    const jsName = (name: string) => {
      rtn[name] = rtnCols[name]
      if (typeof rtn[name] === 'string') rtn[name] = rtn[name].trim()
      switch ($Att[table].columns[name].type) {
        case 'int':
        case 'bigint':
          rtn[name] = (rtn[name] || rtn[name] === 0) ? Math.round(Number(rtn[name])) : null
          break
        case 'float':
          rtn[name] = (rtn[name] || rtn[name] === 0) ? Number(rtn[name]) : null
      }
    }

    const scalarRtn = (selectCols: any) => {
      if (Array.isArray(selectCols)) {
        for (const v of selectCols) {
          if (v !== '*') jsName(v)
        }
      } else
        for (const k in selectCols) {
          if (k !== '*') jsName(k)
        }
    }

    if (Object.keys(rtnCols).length) {
      if (select && Object.keys(select).length) {
        if (Object.keys(select).includes('*')) scalarRtn([...scalarCols, ...Object.keys(select)])
        else scalarRtn(select)
      } // Return all scalar fields of the scalar
      else scalarRtn(scalarCols)

      return rtn
    } else return rtnCols
  }
}
function isValidDate(value: any) {
  const date = new Date(value)
  return !isNaN(date.getTime())
}
const $Queries = function (trx: any, sql: string[] = []) {
  const trxQuery = async (clause: any) => {
    sql.push(clause.toString())
    return await clause
  }

  function argsValidate(
    table: string,
    args: any,
    query: 'select' | 'insert' | 'update' | 'delete',
    trx: any
  ): any {
    const records = Array.isArray(args) ? args : [args]
    const AttCols: any = $Att[table].columns
    // Used to store added or modified columns
    const addedColumns: any = records.map((v) => ({}))
    for (let i = 0; i < records.length; i++) {
      for (const AttCol in AttCols) {
        if (AttCols[AttCol].relation) continue
        if (records[i][AttCol] !== undefined && records[i][AttCol] !== null) {
          // Determine jsType
          if (
            AttCols[AttCol].type === 'enum'
              ? !(<any>$Enum[<$EnumKeys>AttCols[AttCol].jsType]).includes(
                  records[i][AttCol]
                )
              : AttCols[AttCol].type === 'Date'
              ? !isValidDate(records[i][AttCol])
              : AttCols[AttCol].jsType.endsWith(']')
              ? typeof records[i][AttCol] !== 'object'
              : typeof records[i][AttCol] !== AttCols[AttCol].jsType
          ) {
            throw `table "${$Att[table].dbName}" field "${AttCol}" data type mismatch`
          }
          // If it is a number type and an int type
          if (AttCols[AttCol].type === 'int' && typeof records[i][AttCol] === 'number') {
            records[i][AttCol] = <any>Math.round(Number(records[i][AttCol]))
            // Determine if the data exceeds the limit(check constraint)
          } else if (AttCols[AttCol].type === 'object' && typeof records[i][AttCol] === 'object') {
            records[i][AttCol] = <any>JSON.stringify(records[i][AttCol])
          }
        } else {
          // When inserting, if it ia a nullable foreign key, the value is set to null
          if (query === 'insert') {
            if (
              AttCols[AttCol].type === 'id' &&
              !$Att[table].foreignKeys.includes(AttCol) &&
              (AttCols[AttCol].dbType === 'uuid' || AttCols[AttCol].dbType === 'cuid')
            ) {
              addedColumns[i][AttCol] = { uuid: uuidv4(), cuid: cuid() }[AttCols[AttCol].dbType]
            } else if ('required' !== AttCols[AttCol].optional) {
              if ($Att[table].foreignKeys.includes(AttCol)) addedColumns[i][AttCol] = null
            } else {
              throw `"${$Att[table].dbName}": missing required fieldmissing required field: "${AttCol}"`
            }
          }
        }
      }
      if (query === 'update') {
        if ($Att[table].updatedAtColumns && $Att[table].updatedAtColumns.length) {
          for (const AttCol of $Att[table].updatedAtColumns) {
            addedColumns[i][AttCol] = trx.raw('CURRENT_TIMESTAMP')
          }
        }
      }
    }

    const rtns = addedColumns.map((v: object, i: number) => ({
      ...records[i],
      ...v
    }))

    return Array.isArray(args) ? rtns : rtns[0]
  }

  const trxWhere = (Kx: any, table: string, where: any, logic: $WhereLogic = 'AND') => {
    const operator: any = {
      eq: '=',
      lt: '<',
      gt: '>',
      lte: '<=',
      gte: '>=',
      like: 'like'
    }

    const whereLogic = {
      AND: 'where',
      OR: 'orWhere',
      NOT: 'whereNot'
    }[logic]

    for (const key in where) {
      const AttCol = $Att[table].columns[key]
      // is relational field
      if (
        AttCol?.relation &&
        where[key] &&
        typeof where[key] === 'object' &&
        Object.keys(where[key]).length
      ) {
        // Determine if it is a primary key table or a foreign key table
        switch (AttCol.relation.kind) {
          case 'primary':
            // Find the reference field of all records of primary key table that meet the conditions
            if (AttCol.relation.toOne) {
              Kx[whereLogic + 'In'](
                AttCol.relation.references.map(
                  (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                ),
                trxWhere(trx($Att[AttCol.type].dbName), AttCol.type, where[key]).select(
                  AttCol.relation.keys.map(
                    (v) => `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[v].dbName}`
                  )
                )
              )
            } else {
              for (const k in where[key])
                Kx[`where${k === 'some' ? '' : 'Not'}In`](
                  AttCol.relation.references.map(
                    (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                  ),
                  trxWhere(
                    trx($Att[table].dbName)
                      .select(
                        AttCol.relation.references.map(
                          (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
                        )
                      )
                      .innerJoin($Att[AttCol.type].dbName, function (this: any) {
                        for (
                          let i = 0, r = AttCol.relation.references, f = AttCol.relation.keys;
                          i < r.length;
                          i++
                        ) {
                          this.andOn(
                            `${$Att[table].dbName}.${$Att[table].columns[r[i]].dbName}`,
                            '=',
                            `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[f[i]].dbName}`
                          )
                        }
                      }),
                    AttCol.type,
                    where[key][k],
                    k === 'every' ? 'NOT' : undefined
                  )
                )
            }
            break
          case 'foreign':
            Kx[whereLogic + 'In'](
              AttCol.relation.keys.map(
                (v) => `${$Att[table].dbName}.${$Att[table].columns[v].dbName}`
              ),
              trxWhere(trx($Att[AttCol.type].dbName), AttCol.type, where[key]).select(
                AttCol.relation.references.map(
                  (v) => `${$Att[AttCol.type].dbName}.${$Att[AttCol.type].columns[v].dbName}`
                )
              )
            )
            break
          case 'many':
            for (const k in where[key]) {
              Kx[`where${k === 'some' ? '' : 'Not'}In`](
                $Att[table].id.map((v: string) => `${$Att[table].dbName}.${v}`),
                trxWhere(
                  trx(AttCol.relation.mapTable)
                    .select(
                      $Att[table].id.map(
                        (v: string) => `${AttCol.relation.mapTable}.${$Att[table].dbName}_${v}`
                      )
                    )
                    .join($Att[AttCol.type].dbName, function (this: any) {
                      for (const v of $Att[AttCol.type].id) {
                        this.andOn(
                          `${AttCol.relation.mapTable}.${$Att[AttCol.type].dbName}_${v}`,
                          '=',
                          `${$Att[AttCol.type].dbName}.${v}`
                        )
                      }
                    }),
                  AttCol.type,
                  where[key][k],
                  k === 'every' ? 'NOT' : undefined
                )
              )
            }
        }
      } else if (['AND', 'OR', 'NOT'].includes(key)) {
        switch (key) {
          case 'AND':
            if (Array.isArray(where[key])) {
              Kx = Kx['where']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v, <$WhereLogic>key)
                }
              })
            } else if (where[key]) {
              Kx = Kx['where']((builder) => {
                trxWhere(builder, table, where[key], <$WhereLogic>key)
              })
            }
            break
          case 'OR':
            if (Array.isArray(where[key])) {
              Kx = Kx['orWhere']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v)
                }
              })
            } else if (where[key]) {
              Kx = Kx['orWhere']((builder) => {
                trxWhere(builder, table, where[key])
              })
            }
            break
          case 'NOT':
            if (Array.isArray(where[key])) {
              Kx = Kx['whereNot']((builder) => {
                for (const v of where[key]) {
                  trxWhere(builder, table, v)
                }
              })
            } else if (where[key]) {
              Kx = Kx['whereNot']((builder) => {
                trxWhere(builder, table, where[key])
              })
            }
            break
        }
      } else {
        let newKey
        if (key.split(',').length > 1) {
          newKey = key.split(',').map((v) => `${$Att[table].dbName}.${v}`)
        } else {
          newKey = `${$Att[table].dbName}.${key}`
        }
        if (where[key] && typeof where[key] === 'object') {
          Kx = Kx[whereLogic]((builder) => {
            switchScalarCol(builder, where[key], newKey)
          })
        } else {
          Kx =
            where[key] === null
              ? Kx[whereLogic + 'Null'](newKey)
              : Kx[whereLogic](newKey, where[key])
        }
      }
    }

    async function switchScalarCol(Kx, scalarWhere, newKey) {
      const operators = Object.keys(scalarWhere)
      for (const op of operators) {
        let newOp = op,
          newWhere = scalarWhere[op]
        switch (op) {
          case 'contains':
          case 'startsWith':
          case 'endsWith':
            newWhere = `${op === 'startsWith' ? '' : '%'}${newWhere}${op === 'endsWith' ? '' : '%'}`
            newOp = 'like'
          case 'eq':
            if (newWhere === null) {
              Kx = Kx[whereLogic + 'Null'](newKey)
              break
            }
          case 'lt':
          case 'gt':
          case 'lte':
          case 'gte':
          case 'like':
            Kx = Kx[whereLogic](newKey, operator[newOp], newWhere)
            break
          case 'in':
            Kx = Kx[whereLogic + 'In'](
              newKey,
              newWhere.map((v: any) => v)
            )
            break
          case 'between':
            Kx = Kx[whereLogic + 'Between'](newKey, newWhere)
            break
          case 'OR':
            if (Array.isArray(newWhere)) {
              Kx = Kx['orWhere']((builder) => {
                for (const v of newWhere) {
                  switchScalarCol(builder, v, newKey)
                }
              })
            } else if (newWhere) {
              Kx = Kx['orWhere']((builder) => {
                switchScalarCol(builder, newWhere, newKey)
              })
            }
            break
          case 'AND':
            if (Array.isArray(newWhere)) {
              Kx = Kx['where']((builder) => {
                for (const v of newWhere) {
                  switchScalarCol(builder, v, newKey)
                }
              })
            } else if (newWhere) {
              Kx = Kx['where']((builder) => {
                switchScalarCol(builder, newWhere, newKey)
              })
            }
            break
          case 'not':
            if (newWhere !== null && typeof newWhere === 'object') {
              if (Array.isArray(newWhere)) {
                Kx = Kx['whereNot']((builder) => {
                  for (const v of newWhere) {
                    switchScalarCol(builder, v, newKey)
                  }
                })
              } else if (newWhere) {
                Kx = Kx['whereNot']((builder) => {
                  switchScalarCol(builder, newWhere, newKey)
                })
              }
            } else {
              newWhere === null
                ? (Kx =
                    Kx[whereLogic === 'whereNot' ? 'whereNull' : whereLogic + 'NotNull'](newKey))
                : (Kx = Kx[whereLogic === 'whereNot' ? 'where' : whereLogic + 'Not'](
                    newKey,
                    newWhere
                  ))
            }
        }
      }
    }

    return Kx
  }

  // Seperate relation fields into arrays: [scalar,primary,foreign,many]
  const splitCols = (table: string, cols: { [x: string]: any }) =>
    Object.keys(cols).reduce(
      (_: any, k: any) => (
        (_[
          $Att[table].columns[k]?.relation
            ? { primary: 1, foreign: 2, many: 3 }[
                <'primary' | 'foreign' | 'many'>$Att[table].columns[k].relation.kind
              ]
            : 0
        ][k] = cols[k]),
        _
      ),
      [{}, {}, {}, {}]
    )

  // Convert columns into database columns
  const dbCols = (table: string, cols: { [x: string]: any }): any => {
    if (Array.isArray(cols)) {
      const rtn: any = []
      for (const v of cols) rtn.push(dbCols(table, v))
      return rtn
    } else {
      const rtn: any = {}
      for (const k in cols) {
        if ($Att[table].columns[k]) {
          rtn[$Att[table].columns[k].dbName] = cols[k]
        }
      }
      return rtn
    }
  }

  // Update arithmetric operator, only process scalar fields, and add where conditions when calling
  const updateOperator = (table: string, data: { [x: string]: any }) => {
    const Kx = Object.keys(data || {}).reduce((_: any, v) => {
      const col = $Att[table].columns[v]
      if (col.jsType === 'number' && typeof data[v] === 'object') {
        const [[oper, val]] = Object.entries(data[v])
        _ = _[oper](col.dbName, val)
        delete data[v]
      }
      return _
    }, trx($Att[table].dbName))

    return data ? Kx.update(dbCols(table, data)) : Kx
  }

  // Find the unique value of a record
  const recordUnique = (table: string | number, record: { [x: string]: any }) => {
    let uniqueWhere: any = {}
    for (const unique of $Att[table].uniques) {
      if (Array.isArray(unique)) {
        for (const item of unique) {
          if (record[item]) {
            uniqueWhere[item] = record[item]
          } else {
            break
          }
        }
        return uniqueWhere
      } else {
        if (record[unique]) {
          return { [unique]: record[unique] }
        }
      }
    }
  }

  return {
     async finder(
      table: string,
      {
        where = {},
        distinct,
        orderBy,
        limit,
        offset,
        select = { '*': true },
      }: any = {}
    ) {
      // Process where condition
      let Kx = trx($Att[table].dbName)
      if (typeof limit === 'number') Kx = Kx.limit(limit)
      if (typeof offset === 'number') Kx = Kx.offset(offset)
      if (typeof orderBy === 'object') {
        orderBy = Array.isArray(orderBy) ? orderBy : [orderBy]
        Kx = Kx.orderBy(
          orderBy.map((obj: { [s: string]: unknown } | ArrayLike<unknown>) => {
            const [[k, v]] = Object.entries(obj)
            return { column: k, order: v }
          })
        )
      }
      if (distinct)
        Kx = Kx.distinct(
          Array.isArray(distinct) ? distinct.toString() : distinct
        )

      const wKnex = trxWhere(Kx, table, where)
      const AttCols = $Att[table].columns
      sql.push(wKnex.select('*').toString())
      let result = await wKnex.select('*')
      result = $RtnSelect(table, result, {'*': true})
      // Process incoming parameters
      if (Object.keys(select).length) {
        const [scalarCols, relationCols] = Object.keys(select).reduce(
          (_: any, v: string) => {
            if (typeof select[v] === 'object') _[1][v] = select[v]
            else if (select[v] === true) _[0][v] = v
            return _
          },
          [{}, {}]
        )

        for (const key in relationCols) {
          const where: any = relationCols[key].where ?? {}
          let pKeys: any, fKeys: any, relIds

          switch (AttCols[key].relation.kind) {
            case 'primary':
              const rel =
                $Att[AttCols[key].type].columns[AttCols[key].relation.relColumn]
                  .relation
              pKeys = rel.references
              fKeys = rel.keys
              where[fKeys] = {
                in: result.map((v: { [x: string]: any }) =>
                  pKeys.map((v2: string | number) => v[v2])
                ),
              }
              break
            case 'foreign':
              pKeys = AttCols[key].relation.references
              fKeys = AttCols[key].relation.keys
              where[pKeys] = {
                in: result.map((v: { [x: string]: any }) =>
                  fKeys.map((v2: string | number) => v[v2])
                ),
              }
              break
            case 'many':
              const id = $Att[$Att[table].columns[key].type].id
              const tableId = $Att[table].id.map(
                (v2: any) => `${$Att[table].dbName}_${v2}`
              )
              relIds = await trxQuery(
                trx($Att[table].columns[key].relation.mapTable)
                  .select()
                  .whereIn(
                    tableId,
                    result.map((v: { [x: string]: any }) =>
                      $Att[table].id.map((v2: string | number) => v[v2])
                    )
                  )
              )
              // @ts-ignore
              where[id] = {
                in: relIds.map((v: { [x: string]: any }) =>
                  id
                    .map((v2: any) =>
                      Object.values({
                        [v2]: v[
                          `${$Att[$Att[table].columns[key].type].dbName}_${v2}`
                        ],
                      })
                    )
                    .flat()
                ),
              }
              break
          }
          const relationResult = await this.finder(AttCols[key].type, {
            where,
            orderBy: relationCols[key].orderBy,
            limit: relationCols[key].limit,
            offset: relationCols[key].offset,
            distinct: relationCols[key].distinct,
            select: relationCols[key].select ?? select[key],
          })

          for (const v of result) {
            switch (AttCols[key].relation.kind) {
              case 'primary':
              case 'foreign':
                v[key] = relationResult.filter(
                  (r: { [x: string]: string }) =>
                    `${(AttCols[key].relation.kind === 'primary'
                      ? fKeys
                      : pKeys
                    )
                      .map((v2: string | number) =>
                        r[v2] ? r[v2].trim() : null
                      )
                      .join('_')}` ===
                    `${(AttCols[key].relation.kind === 'primary'
                      ? pKeys
                      : fKeys
                    )
                      .map((v2: string | number) =>
                        v[v2] ? v[v2].trim() : null
                      )
                      .join('_')}`
                )
                if (
                  AttCols[key].relation.toOne ||
                  AttCols[key].relation.kind === 'foreign'
                )
                  v[key] = v[key][0] || null
                break
              case 'many':
                const id = $Att[$Att[table].columns[key].type].id
                const tableId = $Att[table].id.map(
                  (v2: any) => `${$Att[table].dbName}_${v2}`
                )
                const mapTableData = relIds
                  .filter(
                    (r: { [x: string]: string }) =>
                      tableId
                        .map((v2: string | number) =>
                          r[v2] ? r[v2].trim() : null
                        )
                        .join('_') ==
                      $Att[table].id
                        .map((v2: string | number) =>
                          v[v2] ? v[v2].trim() : null
                        )
                        .join('_')
                  )
                  .map((v3: { [x: string]: string }) =>
                    id
                      .map((v2: any) =>
                        v3[
                          `${$Att[$Att[table].columns[key].type].dbName}_${v2}`
                        ]
                          ? v3[
                              `${
                                $Att[$Att[table].columns[key].type].dbName
                              }_${v2}`
                            ].trim()
                          : null
                      )
                      .join('_')
                  )
                v[key] = relationResult.filter((r: { [x: string]: string }) =>
                  mapTableData.includes(
                    id
                      .map((v2: string | number) =>
                        r[v2] ? r[v2].trim() : null
                      )
                      .join('_')
                  )
                )
            }
            v[key] =
              v[key] &&
              $RtnSelect(
                AttCols[key].type,
                v[key],
                typeof relationCols[key].select === 'object'
                  ? relationCols[key].select
                  : relationCols[key]
              )
          }
        }
      }
      
      return result
    },

    async insert(table: string, args: any) {
      let scalarRtn: Array<any>

      if (Array.isArray(args.data)) {
        // is an array, filter each record in the array, and seperate out if there is a relational field
        
        const scalarRecords = []
        const relationRecords = []
        for (const val of args.data){
          const [scalarCols, primaryCols, foreignCols, manyCols] = splitCols(table, val)
          if (Object.keys(foreignCols).length) {
            const relColumns: any = Object.entries(foreignCols)
            // If there exists a foreign key field, you must create a primary key table to obtain the referenced field value
            for (const [k, v] of relColumns) {
              const AttCol = $Att[table].columns[k]
              const { references, keys } = AttCol.relation
              if (v.connectOrInsert) {
                // Find if the connection exists
                let pTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                    .select('*')
                )
  
                ;[pTable] = pTable.length
                  ? pTable
                  : await this.insert(AttCol.type, {
                      data: v.connectOrInsert.insert
                    })
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
              if (v.connect) {
                // Find the connection
                let [pTable] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
                )
                if (!pTable)
                  throw `table found "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                    v.connect
                  )}" does not exist`
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
              if (v.insert) {
                let [pTable] = await this.insert(AttCol.type, {
                  data: v.insert
                })
                pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
                for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
              }
            }
          }
          if (Object.keys(scalarCols).length) {
            scalarRecords.push(scalarCols)
          }
          
          if (Object.keys(primaryCols).length) {
            relationRecords.push(primaryCols)
          }
          if (Object.keys(manyCols).length) {
            relationRecords.push(manyCols)
          }
        }
        // Create pure scalar record
        if (scalarRecords.length) {
          scalarRtn = await trxQuery(
            trx($Att[table].dbName)
              .insert(dbCols(table, argsValidate(table, scalarRecords, 'insert', trx)))
              .returning('*')
          )
        } else {
          scalarRtn = []
        }

        if (relationRecords.length) {
          for (const record of relationRecords) {
            scalarRtn = scalarRtn.concat(
              await this.insert(table, {
                data: record,
                select: args.select
              })
            )
          }
        }

        return scalarRtn
      } else {
        // is single record, seperate out scalar fields, relational(primary key table, foreign key table, many-to-many table) fields
        const [scalarCols, primaryCols, foreignCols, manyCols] = splitCols(table, args.data)

        // When there is a foreign key field, create its primary key table and get tje foreign key value
        if (Object.keys(foreignCols).length) {
          const relColumns: any = Object.entries(foreignCols)
          // If there exists a foreign key field, you must create a primary key table to obtain the referenced field value
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            if (v.connectOrInsert) {
              // Find if the connection exists
              let pTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                  .select('*')
              )

              ;[pTable] = pTable.length
                ? pTable
                : await this.insert(AttCol.type, {
                    data: v.connectOrInsert.insert
                  })
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
            if (v.connect) {
              // Find the connection
              let [pTable] = await trxQuery(
                trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
              )
              if (!pTable)
                throw `table found "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                  v.connect
                )}" does not exist`
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
            if (v.insert) {
              let [pTable] = await this.insert(AttCol.type, {
                data: v.insert
              })
              pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
              for (let i = 0; i < keys.length; i++) scalarCols[keys[i]] = pTable[references[i]]
            }
          }
        }
        // Create this table and get the uniqur field for foreign key table to use
        scalarRtn = await trxQuery(
          trx($Att[table].dbName)
            .insert(dbCols(table, argsValidate(table, scalarCols, 'insert', trx)))
            .returning('*')
        )
        scalarRtn = $RtnSelect(table, scalarRtn, { '*': true })
        // Create all foreign key tables and apply the unique key of this table to the corresponding table
        if (Object.keys(primaryCols).length) {
          const relColumns: any = Object.entries(primaryCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            const relationForeign: any = {}
            for (let i = 0; i < keys.length; i++)
              relationForeign[keys[i]] = scalarRtn[0][references[i]]
            // ont-to-one relationship
            if (AttCol.relation?.toOne) {
              if (v.connectOrInsert) {
                let rTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
                if (!rTable.length)
                  await this.insert(AttCol.type, {
                    data: {
                      ...v.connectOrInsert.insert,
                      ...relationForeign
                    }
                  })
              }
              if (v.connect) {
                await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: { ...v.insert, ...relationForeign }
                })
              }
            } else {
              // one-to-many relationship
              if (v.connectOrInsert) {
                if (!Array.isArray(v.connectOrInsert)) v.connectOrInsert = [v.connectOrInsert]
                for (const val of v.connectOrInsert) {
                  let rTable = await trxQuery(
                    trx($Att[AttCol.type].dbName)
                      .where(dbCols(AttCol.type, val.connect))
                      .update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                      .returning('*')
                  )
                  if (!rTable.length)
                    await this.insert(AttCol.type, {
                      data: {
                        ...val.insert,
                        ...relationForeign
                      }
                    })
                }
              }
              if (v.connect) {
                if (!Array.isArray(v.connect)) v.connect = [v.connect]
                await trxQuery(
                  trx.raw(
                    v.connect
                      .reduce(
                        (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                        trx($Att[AttCol.type].dbName).update(
                          dbCols(
                            AttCol.type,
                            argsValidate(AttCol.type, relationForeign, 'update', trx)
                          )
                        )
                      )
                      .toString()
                  )
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: Array.isArray(v.insert)
                    ? v.insert.map((val: any) => ({
                        ...val,
                        ...relationForeign
                      }))
                    : { ...v.insert, ...relationForeign }
                })
              }
            }
          }
        }
        // Create many-to-many relational field
        if (Object.keys(manyCols).length) {
          // Mapping table id
          const mapTabelId = $Att[table].id.reduce(
            (_: any, v: string | number) => (
              (_[`${$Att[table].dbName}_${v}`] = scalarRtn[0][v]), _
            ),
            {}
          )
          const relColumns: any = Object.entries(manyCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            // id of this table
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              // Query the id of each record in the relational table
              for (const item of items) {
                let [relMapTableId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(item).select($Att[AttCol.type].id)
                )

                relMapTableId = Object.keys(relMapTableId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relMapTableId[v]), _),
                  {}
                )
                // upsert data to the mapping table
                const mapRecord = { ...mapTabelId, ...relMapTableId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              const ret = await this.insert(AttCol.type, {
                data: v.insert,
                select: $ArrayTrue($Att[AttCol.type].id)
              })
              let relMapTableIds = ret.map((record) =>
                Object.keys(record).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = record[v]), _),
                  {}
                )
              )

              await trxQuery(
                trx(AttCol.relation.mapTable).insert(
                  relMapTableIds.map((v) => ({
                    ...mapTabelId,
                    ...v
                  }))
                )
              )
            }
          }
        }

        return scalarRtn
      }
    },

    async upsert(table: string, args: any) {
      const contained = await trxQuery(trx($Att[table].dbName).where(args.where).select('*'))

      return contained.length
        ? args.update
          ? await this.update(table, {
              where: args.where,
              data: args.update,
              select: args.select
            })
          : await this.finder(table, {
              where: args.where,
              select: args.select
            })
        : await this.insert(table, {
            data: args.insert,
            select: args.select
          })
    },

    async update(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length) throw `where cannot be empty`
      // Find the record and return if not exist
      if (!args.data) throw `Modified table "${table}" does not have incoming data`
      const trxTmp = await trxQuery(trx($Att[table].dbName).where(args.where).select('*'))
      if (!trxTmp.length)
        throw `table "${$Att[table].dbName}" has no record for the condition: "${args.where}"`

      const [scalarColumns, primaryColumns, foreignColumns, manyColumns] = splitCols(
        table,
        args.data
      )

      if (Object.keys(foreignColumns).length) {
        const relColumns: any = Object.entries(foreignColumns)

        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          // Use foreign keys as where condition
          let foreignWhere: any = {},
            currTable: any
          for (let i = 0; i < references.length; i++) {
            foreignWhere[references[i]] =
              args.where[keys[i]] || (!currTable && ([currTable] = trxTmp), currTable[keys[i]])
          }
          if (v.connectOrInsert) {
            // Find if the connection exists
            let pTable = await trxQuery(
              trx($Att[AttCol.type].dbName)
                .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                .select('*')
            )

            ;[pTable] = pTable.length
              ? pTable
              : await this.insert(AttCol.type, {
                  data: v.connectOrInsert.insert
                })
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.connect) {
            // Find the connection
            let [pTable] = await trxQuery(
              trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, v.connect)).select('*')
            )

            if (!pTable)
              throw `query table "${$Att[AttCol.type].dbName}" record "${JSON.stringify(
                v.connect
              )}" does not exist`
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.insert) {
            let [pTable] = await this.insert(AttCol.type, {
              data: v['insert']
            })
            pTable = $RtnSelect(AttCol.type, pTable, { '*': true })
            for (let i = 0; i < keys.length; i++) scalarColumns[keys[i]] = pTable[references[i]]
          }
          if (v.upsert) {
            await this.upsert(AttCol.type, {
              ...v.upsert,
              where: foreignWhere
            })
          }
          if (v.update) {
            await this.update(AttCol.type, {
              where: foreignWhere,
              data: v.update
            })
          }
          if (v.delete === true) {
            await trxQuery(
              trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, foreignWhere)).del()
            )
          }
          if (v.disconnect === true) {
            await keys.reduce((_: any, v: string) => ((_[v] = null), _), scalarColumns)
          }
        }
      }

      // Modify this table
      let tableRtn
      if (Object.keys(scalarColumns).length) {
        const trxTmp = await trxQuery(
          trx($Att[table].dbName)
            .where(dbCols(table, args.where))
            .update(dbCols(table, argsValidate(table, scalarColumns, 'update', trx)))
            .returning('*')
        )
        tableRtn = trxTmp
      } else {
        tableRtn = await trxWhere(
          trx($Att[table].dbName).select(args.select ? Object.keys(args.select) : '*'),
          table,
          args?.where
        )
      }
      tableRtn = $RtnSelect(table, tableRtn, { '*': true })

      if (Object.keys(primaryColumns).length) {
        const relColumns: any = Object.entries(primaryColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          const relationForeign: any = {}
          for (let i = 0; i < keys.length; i++)
            relationForeign[keys[i]] = tableRtn[0][references[i]]
          if (AttCol.relation?.toOne) {
            if (v.connectOrInsert) {
              let rTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connectOrInsert.connect))
                  .update(
                    dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                  )
                  .returning('*')
              )

              if (!rTable.length)
                await this.insert(AttCol.type, {
                  data: {
                    ...v.connectOrInsert.insert,
                    ...relationForeign
                  }
                })
            }
            if (v.connect) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connect))
                  .update(
                    dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                  )
                  .returning('*')
              )
            }
            if (v.insert) {
              await this.insert(AttCol.type, {
                data: {
                  ...v.insert,
                  ...relationForeign
                }
              })
            }
            if (v.upsert) {
              await this.upsert(AttCol.type, {
                ...v.upsert,
                where: relationForeign
              })
            }
            if (v.update) {
              await this.update(AttCol.type, {
                where: relationForeign,
                data: v.update
              })
            }
            if (v.delete === true) {
              await trxQuery(
                trx($Att[AttCol.type].dbName).where(dbCols(AttCol.type, relationForeign)).del()
              )
            }
            if (v.disconnect === true) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, relationForeign))
                  .update(
                    dbCols(
                      AttCol.type,
                      argsValidate(
                        AttCol.type,
                        keys.reduce((_: any, v: any) => ((_[v] = null), _), {}),
                        'update',
                        trx
                      )
                    )
                  )
              )
            }
          } else {
            // one-to-many relationship
            if (v.disconnect) {
              await trxQuery(
                trx.raw(
                  trxWhere(
                    v.disconnect.reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(
                            AttCol.type,
                            keys.reduce((_: any, v: any) => ((_[v] = null), _), {}),
                            'update',
                            trx
                          )
                        )
                      )
                    ),
                    AttCol.type,
                    relationForeign
                  ).toString()
                )
              )
            }
            if (v.deleteMany) {
              await trxQuery(
                trx.raw(
                  trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, {
                    ...v.deleteMany,
                    ...relationForeign
                  }).toString()
                )
              )
            }

            if (v.set) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, relationForeign))
                  .update(
                    dbCols(
                      AttCol.type,
                      keys.reduce((_: any, v: any) => ((_[v] = null), _), {})
                    )
                  )
              )
              if (!Array.isArray(v.set)) v.set = [v.set]
              await trxQuery(
                trx.raw(
                  v.set
                    .reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                    )
                    .toString()
                )
              )
            }
            if (v.connectOrInsert) {
              if (!Array.isArray(v.connectOrInsert)) v.connectOrInsert = [v.connectOrInsert]
              for (const val of v.connectOrInsert) {
                let rTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, val.connect))
                    .update(
                      dbCols(AttCol.type, argsValidate(AttCol.type, relationForeign, 'update', trx))
                    )
                    .returning('*')
                )
                if (!rTable.length)
                  await this.insert(AttCol.type, {
                    data: {
                      ...val.insert,
                      ...relationForeign
                    }
                  })
              }
            }
            if (v.connect) {
              if (!Array.isArray(v.connect)) v.connect = [v.connect]
              await trxQuery(
                trx.raw(
                  v.connect
                    .reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(
                        dbCols(
                          AttCol.type,
                          argsValidate(AttCol.type, relationForeign, 'update', trx)
                        )
                      )
                    )
                    .toString()
                )
              )
            }
            if (v.insert) {
              await this.insert(AttCol.type, {
                data: Array.isArray(v.insert)
                  ? v.insert.map((val: any) => ({
                      ...val,
                      ...relationForeign
                    }))
                  : { ...v.insert, ...relationForeign }
              })
            }
            if (v.upsert) {
              if (!Array.isArray(v.upsert)) v.upsert = [v.upsert]
              for (const val of v.upsert) {
                await this.upsert(AttCol.type, {
                  where: val.where,
                  update: val.update,
                  insert: { ...val.insert, ...relationForeign }
                })
              }
            }
            if (v.update) {
              if (!Array.isArray(v.update)) v.update = [v.update]
              for (const val of v.update) {
                await this.update(AttCol.type, {
                  where: {
                    ...val.where,
                    ...relationForeign
                  },
                  data: val.data
                })
              }
            }
            if (v.updateMany) {
              await trxQuery(
                trx.raw(
                  trxWhere(
                    trx($Att[AttCol.type].dbName).update(
                      dbCols(
                        AttCol.type,
                        argsValidate(AttCol.type, v.updateMany.data, 'update', trx)
                      )
                    ),
                    AttCol.type,
                    {
                      ...v.updateMany.where,
                      ...relationForeign
                    }
                  ).toString()
                )
              )
            }
            if (v.delete) {
              if (!Array.isArray(v.delete)) v.delete = [v.delete]
              for (const val of v.delete) {
                await trxQuery(
                  trx.raw(
                    trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, {
                      ...val,
                      ...relationForeign
                    }).toString()
                  )
                )
              }
            }
          }
        }
      }
      // many-to-many relationship
      if (Object.keys(manyColumns).length) {
        const relColumns: any = Object.entries(manyColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          // this table id
          let tableId
          if (args.where[$Att[table].id.join('_')]) {
            tableId = args.where
          } else {
            tableId = (
              await trxQuery(trx($Att[table].dbName).where(args.where).select($Att[table].id))
            )[0]
          }
          // id of mapping table
          let mapTableId: any = {}
          for (const k in tableId) {
            mapTableId[`${$Att[table].dbName}_${k}`] = tableId[k]
          }
          // ids of relational tables
          const trxTmp = await trxQuery(trx(AttCol.relation.mapTable).where(mapTableId).select('*'))
          const relTableIds = trxTmp.map((v: { [x: string]: any }) => {
            $Att[AttCol.type].id.reduce(
              (_: { [x: string]: any }, v2: string | number) => (
                (_[v2] = v[`${$Att[AttCol.type].dbName}_${v2}`]), _
              ),
              {}
            )
          })

          if (v.set) {
            const items = Array.isArray(v.set) ? v.set : [v.set]
            // for (const item of items) relTableId = relTableId.concat(await updateSet(item))

            // Delete the old relationships in the mapping table and store the new relationships
            await trxQuery(trx(AttCol.relation.mapTable).where(mapTableId).del())

            for (const v of items) {
              let [relId] = await trxQuery(
                trx($Att[AttCol.type].dbName).where(v).select($Att[AttCol.type].id)
              )
              relId = Object.keys(relId).reduce(
                (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _),
                {}
              )
              const mapRecord = { ...mapTableId, ...relId }
              await trxQuery(
                trx(AttCol.relation.mapTable)
                  .insert(mapRecord)
                  .onConflict(Object.keys(mapRecord))
                  .ignore()
              )
            }
          } else {
            let ids: any[] = []
            if (v.disconnect) {
              const items = Array.isArray(v.disconnect) ? v.disconnect : [v.disconnect]
              for (const v of items) {
                let [relId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(v).select($Att[AttCol.type].id)
                )
                relId = Object.keys(relId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _),
                  {}
                )
                const mapRecord = { ...mapTableId, ...relId }
                await trxQuery(trx(AttCol.relation.mapTable).where(mapRecord).del())
              }
            }
            if (v.deleteMany) {
              const where = trxWhere(trx($Att[AttCol.type].dbName).del(), AttCol.type, v.deleteMany)

              await trxWhere(where, AttCol.type, {
                // @ts-ignore
                [$Att[AttCol.type].id]: {
                  in: relTableIds.map((v: any) => Object.values(v))
                }
              })
            }
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              for (const v of items) {
                let [relId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(v).select($Att[AttCol.type].id)
                )
                relId = Object.keys(relId).reduce(
                  (_: any, v) => ((_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _),
                  {}
                )
                const mapRecord = { ...mapTableId, ...relId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              // There may be a problem---------------------------------------------------------------------------------
              const updateInsert = async (record: any) =>
                await this.upsert(AttCol.type, {
                  where: recordUnique(AttCol.type, record),
                  insert: record
                })
              const items = Array.isArray(v.insert) ? v.insert : [v.insert]
              ids = await updateInsert(items)

              for (const v2 of ids) {
                const tableId = mapTableId
                for (const v3 of $Att[AttCol.type].id) {
                  tableId[`${$Att[AttCol.type].dbName}_${v3}`] = v2[v3]
                }
                await trxQuery(trx(AttCol.relation.mapTable).insert(tableId))
              }
            }
            if (v.upsert) {
              const items = Array.isArray(v.upsert) ? v.upsert : [v.upsert]
              for (const item of items) {
                await this.upsert(AttCol.type, item)
              }
            }
            if (v.update) {
              const items = Array.isArray(v.update) ? v.update : [v.update]
              for (const item of items) {
                await this.update(AttCol.type, item)
              }
            }
            if (v.updateMany) {
              await this.updateMany(AttCol.type, v.updateMany)
            }
            if (v.delete) {
              const items = Array.isArray(v.delete) ? v.delete : [v.delete]
              await items.reduce(
                (_: any, v) => trxWhere(_, AttCol.type, v, 'OR'),
                trx($Att[AttCol.type].dbName).del()
              )
              // Delete the corresponding records in the mapping table (subsequent improvement)
            }
          }
        }
      }

      return tableRtn
    },

    async updateMany(table: string, args: any) {
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(
        wKnex.update(argsValidate(table, dbCols(table, args.data), 'update', trx))
      )
    },

    async delete(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length) throw `where cannot be empty`
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(wKnex.del().returning('*'))
    },

    async deleteMany(table: string, args: any) {
      let Kx = trx($Att[table].dbName)
      const wKnex = trxWhere(Kx, table, args.where)
      return await trxQuery(wKnex.del())
      // return await trxQuery(trx($Att[table].dbName).where(args?.where).del())
    },

    async aggregate(table: string, args: any) {
      // if (!args?.select || args.select === '*') (<any>args).select = { count: '*' }
      const aggregates = [
        'count',
        'countDistinct',
        'sum',
        'sumDistinct',
        'avg',
        'avgDistinct',
        'max',
        'min'
      ]
      let Kx = trx.from(`${$Att[table].dbName} as ${$Att[table].dbName}`)
      if (typeof args.limit === 'number') Kx = Kx.limit(args.limit)
      if (typeof args.offset === 'number') Kx = Kx.offset(args.offset)
      const wKnex = trxWhere(Kx, table, args.where)
      for (const key in args) {
        if (
          aggregates.includes(key) &&
          args[key] &&
          typeof args[key] === 'object' &&
          Object.keys(args[key])
        ) {
          Object.keys(args[key]).forEach((k) => {
            if (args[key][k]) {
              if (k === '*' && ['count', 'countDistinct'].includes(key)) {
                wKnex[key](`* as ${key}->${k}`)
              } else if ($Att[table].columns[k]) {
                wKnex[key](`${$Att[table].columns[k].dbName} as ${key}->${k}`)
              }
            }
          })
        }
      }
      sql.push(wKnex.toString())
      let result = await wKnex
      result = result[0]
      const returning = {}
      for (const key in args) {
        if (
          aggregates.includes(key) &&
          args[key] &&
          typeof args[key] === 'object' &&
          Object.keys(args[key])
        ) {
          Object.keys(args[key]).forEach((k) => {
            if (args[key][k]) {
              if (returning[key]) {
                returning[key][k] = Number(result[`${key}->${k}`])
              } else {
                returning[key] = {
                  [k]: Number(result[`${key}->${k}`])
                }
              }
            }
          })
        }
      }
      return returning
    }
  }
}