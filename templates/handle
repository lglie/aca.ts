// Convert the items of the array list to the boolean form of returning format
const $ArrayTrue = (arrayItem: string[]) =>
  arrayItem.reduce((_:any, v) => ((_[v] = true), _), {})

// Process the returned database record
function $RtnSelect(table: string, rtnCols: any, select?: any):any {
  if (Array.isArray(rtnCols)) {
    const rtn = []
    for (const v of rtnCols) rtn.push($RtnSelect(table, v, select))
    return rtn
  } else {
    const rtn:any = {}
    const scalarCols = $Att[table].scalarColumns

    const jsName = (name: string) => {
      rtn[name] = rtnCols[name]
      if (typeof rtn[name] === 'string') rtn[name] = rtn[name].trim()
      switch ($Att[table].columns[name].type) {
        case 'int':
        case 'bigint':
          rtn[name] = Math.round(Number(rtn[name]))
          break
        case 'float':
          rtn[name] = Number(rtn[name])
      }
    }

    const scalarRtn = (selectCols: any) => {
      if (Array.isArray(selectCols)) {
        for (const v of selectCols) {
          if (v !== '*') jsName(v)
        }
      } else
        for (const k in selectCols) {
          if (k !== '*') jsName(k)
        }
    }

    if (Object.keys(rtnCols).length) {
      if (select && Object.keys(select).length) {
        if (Object.keys(select).includes('*'))
          scalarRtn([...scalarCols, ...Object.keys(select)])
        else scalarRtn(select)
      } // Return all scalar fields of the scalar
      else scalarRtn(scalarCols)

      return rtn
    } else return rtnCols
  }
}
function isValidDate(value:any) {
  const date = new Date(value)
  return !isNaN(date.getTime())
}

const $Queries = function (trx: any, sql: string[] = []) {
  const trxQuery = async (clause: any) => {
    sql.push(clause.toString())
    return await clause
  }

  function argsValidate(
    table: string,
    args: any,
    query: 'select' | 'insert' | 'update' | 'delete'
  ): any {
    const records = Array.isArray(args) ? args : [args]
    const AttCols:any = $Att[table].columns
    // Used to store added or modified columns
    const addedColumns:any = records.map((v) => ({}))
    for (let i = 0; i < records.length; i++) {
      for (const AttCol in AttCols) {
        if (AttCols[AttCol].relation) continue
        if (records[i][AttCol] !== undefined && records[i][AttCol] !== null) {
          // Determine jsType
          if (
            AttCols[AttCol].type === 'enum'
              ? !(<any>$Enum[<$EnumKeys>AttCols[AttCol].jsType]).includes(
                  records[i][AttCol]
                )
              : AttCols[AttCol].type === 'Date'
              ? !isValidDate(records[i][AttCol])
              : typeof records[i][AttCol] !== AttCols[AttCol].jsType
          ) {
            throw `table "${$Att[table].dbName}" field "${AttCol}" data type mismatch`
          }
          // If it is a number type and an int type
          if (
            AttCols[AttCol].type === 'int' &&
            typeof records[i][AttCol] === 'number'
          ) {
            records[i][AttCol] = <any>Math.round(Number(records[i][AttCol]))
            // Determine if the data exceeds the limit(check constraint)
          } else if (
            AttCols[AttCol].type === 'object' &&
            typeof records[i][AttCol] === 'object'
          ) {
            records[i][AttCol] = <any>JSON.stringify(records[i][AttCol])
          }
        } else {
          // When inserting, if it ia a nullable foreign key, the value is set to null
          if (query === 'insert') {
            if (
              AttCols[AttCol].type === 'id' &&
              !$Att[table].foreignKeys.includes(AttCol) &&
              (AttCols[AttCol].dbType === 'uuid' ||
                AttCols[AttCol].dbType === 'cuid')
            ) {
              
              addedColumns[i][AttCol] = { uuid: uuidv4(), cuid: cuid() }[
                <'uuid' | 'cuid'>AttCols[AttCol].dbType
              ]
            } else if ('required' !== AttCols[AttCol].optional) {
              if ($Att[table].foreignKeys.includes(AttCol))
                addedColumns[i][AttCol] = null
            } else {
              throw `"${$Att[table].dbName}": missing required fieldmissing required field: "${AttCol}"`
            }
          }
        }
      }
    }

    const rtns = addedColumns.map((v: object, i: number) => ({
      ...records[i],
      ...v,
    }))

    return Array.isArray(args) ? rtns : rtns[0]
  }

  const trxWhere = (
    Kx: any,
    table: string,
    where: any,
    logic: $WhereLogic = 'AND'
  ) => {
    const operator:any = {
      eq: '=',
      lt: '<',
      gt: '>',
      lte: '<=',
      gte: '>=',
      like: 'like',
    }

    const whereLogic = {
      AND: 'where',
      OR: 'orWhere',
      NOT: 'whereNot',
    }[logic]

    for (const key in where) {
      const AttCol = $Att[table].columns[key]
      // is relational field
      if (AttCol?.relation) {
        // Determine if it is a primary key table or a foreign key table
        switch (AttCol.relation.kind) {
          case 'primary':
            // Find the reference field of all records of primary key table that meet the conditions
            if (AttCol.relation.toOne) {
              Kx[whereLogic + 'In'](
                AttCol.relation.references,
                trxWhere(
                  trx($Att[AttCol.type].dbName),
                  AttCol.type,
                  where[key]
                ).select(AttCol.relation.keys)
              )
            } else {
              for (const k in where[key])
                Kx[`where${k === 'some' ? '' : 'Not'}In`](
                  AttCol.relation.references,
                  trxWhere(
                    trx($Att[table].dbName)
                      .select(
                        `${$Att[table].dbName}.${AttCol.relation.references}`
                      )
                      .innerJoin(
                        $Att[AttCol.type].dbName,
                        function (this: any) {
                          for (
                            let i = 0,
                              r = AttCol.relation.references,
                              f = AttCol.relation.keys;
                            i < r.length;
                            i++
                          ) {
                            this.andOn(
                              `${$Att[table].dbName}.${r[i]}`,
                              '=',
                              `${$Att[AttCol.type].dbName}.${f[i]}`
                            )
                          }
                        }
                      ),
                    AttCol.type,
                    where[key][k],
                    k === 'every' ? 'NOT' : undefined
                  )
                )
            }
            break
          case 'foreign':
            Kx[whereLogic + 'In'](
              AttCol.relation.keys,
              trxWhere(
                trx($Att[AttCol.type].dbName),
                AttCol.type,
                where[key]
              ).select(AttCol.relation.references)
            )
            break
          case 'many':
            for (const k in where[key]) {
              Kx[`where${k === 'some' ? '' : 'Not'}In`](
                $Att[table].id.map((v: string) => `${$Att[table].dbName}.${v}`),
                trxWhere(
                  trx(AttCol.relation.mapTable)
                    .select(
                      $Att[table].id.map(
                        (v: string) =>
                          `${AttCol.relation.mapTable}.${$Att[table].dbName}_${v}`
                      )
                    )
                    .join($Att[AttCol.type].dbName, function (this: any) {
                      for (const v of $Att[AttCol.type].id) {
                        this.andOn(
                          `${AttCol.relation.mapTable}.${
                            $Att[AttCol.type].dbName
                          }_${v}`,
                          '=',
                          `${$Att[AttCol.type].dbName}.${v}`
                        )
                      }
                    }),
                  AttCol.type,
                  where[key][k],
                  k === 'every' ? 'NOT' : undefined
                )
              )
            }
        }
      } else if (['AND', 'OR', 'NOT'].includes(key)) {
        if (Array.isArray(where[key])) {
          for (const v of where[key]) {
            trxWhere(Kx, table, v, <$WhereLogic>key)
          }
        } else if (where[key]) {
          trxWhere(Kx, table, where[key])
        }
      } else {
        let newKey = `${$Att[table].dbName}.${key}`
        if (where[key] && typeof where[key] === 'object') {
          const operators = Object.keys(where[key])
          for (const op of operators) {
            let newOp = op,
              newWhere = where[key][op]
            switch (op) {
              case 'contains':
              case 'startsWith':
              case 'endsWith':
                newWhere = `${op === 'startsWith' ? '' : '%'}${newWhere}${
                  op === 'endsWith' ? '' : '%'
                }`
                newOp = 'like'
              case 'eq':
                if (newWhere === null) {
                  Kx = Kx[whereLogic + 'Null'](newKey)
                  break
                }
              case 'lt':
              case 'gt':
              case 'lte':
              case 'gte':
              case 'like':
                Kx = Kx[whereLogic](newKey, operator[newOp], newWhere)
                break
              case 'in':
                Kx = key.includes(',')
                  ? Kx[whereLogic + 'In'](
                      key.split(',').map((v) => `${$Att[table].dbName}.${v}`),
                      newWhere
                    )
                  : Kx[whereLogic + 'In'](
                      newKey,
                      newWhere.map((v: any) => v)
                    )
                break
              case 'between':
                Kx = Kx[whereLogic + 'Between'](newKey, newWhere)
                break
              case 'not':
                if (newWhere !== null && typeof newWhere === 'object')
                  for (const key2 in newWhere) {
                    switch (key2) {
                      case 'eq':
                        newWhere.eq === null
                          ? (Kx =
                              Kx[
                                whereLogic === 'whereNot'
                                  ? 'whereNull'
                                  : whereLogic + 'NotNull'
                              ](newKey))
                          : (Kx = Kx[
                              whereLogic === 'whereNot'
                                ? 'where'
                                : whereLogic + 'Not'
                            ](newKey, newWhere.eq))

                        break
                      case 'like':
                        Kx = Kx[
                          whereLogic === 'whereNot'
                            ? 'where'
                            : whereLogic + 'Not'
                        ](newKey, 'like', newWhere.like)
                        break
                      case 'in':
                        Kx = key.includes(',')
                          ? Kx[
                              whereLogic === 'whereNot'
                                ? 'whereIn'
                                : whereLogic + 'NotIn'
                            ](
                              key
                                .split(',')
                                .map((v) => `${$Att[table].dbName}.${v}`),
                              newWhere.in
                            )
                          : Kx[
                              whereLogic === 'whereNot'
                                ? 'whereIn'
                                : whereLogic + 'NotIn'
                            ](newKey, newWhere.in)

                        break
                      case 'between':
                        Kx = Kx[
                          whereLogic === 'whereNot'
                            ? 'whereBetween'
                            : whereLogic + 'NotBetween'
                        ](newKey, newWhere.between)
                    }
                  }
                else {
                  newWhere === null
                    ? (Kx =
                        Kx[
                          whereLogic === 'whereNot'
                            ? 'whereNull'
                            : whereLogic + 'NotNull'
                        ](newKey))
                    : (Kx = Kx[
                        whereLogic === 'whereNot' ? 'where' : whereLogic + 'Not'
                      ](newKey, newWhere))
                }
            }
          }
        } else {
          Kx =
            where[key] === null
              ? Kx[whereLogic + 'Null'](newKey)
              : Kx[whereLogic](newKey, where[key])
        }
      }
    }

    return Kx
  }

  // Seperate relation fields into arrays: [scalar,primary,foreign,many]
  const splitCols = (table: string, cols: { [x: string]: any }) =>
    Object.keys(cols).reduce(
      (_: any, k: any) => (
        (_[
          $Att[table].columns[k]?.relation
            ? { primary: 1, foreign: 2, many: 3 }[
                <'primary'|'foreign'|'many'>$Att[table].columns[k].relation.kind
              ]
            : 0
        ][k] = cols[k]),
        _
      ),
      [{}, {}, {}, {}]
    )

  // Convert columns into database columns
  const dbCols = (table: string, cols: { [x: string]: any }):any => {
    if (Array.isArray(cols)) {
      const rtn = []
      for (const v of cols) rtn.push(dbCols(table, v))
      return rtn
    } else {
      const rtn:any = {}
      for (const k in cols) {
        rtn[$Att[table].columns[k].dbName] = cols[k]
      }
      return rtn
    }
  }

  // Update arithmetric operator, only process scalar fields, and add where conditions when calling
  const updateOperator = (table: string, data: { [x: string]: any }) => {
    const Kx = Object.keys(data || {}).reduce((_:any, v) => {
      const col = $Att[table].columns[v]
      if (col.jsType === 'number' && typeof data[v] === 'object') {
        const [[oper, val]] = Object.entries(data[v])
        _ = _[oper](col.dbName, val)
        delete data[v]
      }
      return _
    }, trx($Att[table].dbName))

    return data ? Kx.update(dbCols(table, data)) : Kx
  }

  // Find the unique value of a record
  const recordUnique = (table: string | number, record: { [x: string]: any }) => {
    let uniqueWhere:any = {}
    for (const unique of $Att[table].uniques) {
      if (Array.isArray(unique)) {
        for (const item of unique) {
          if (record[item]) {
            uniqueWhere[item] = record[item]
          } else {
            break
          }
        }
        return uniqueWhere
      } else {
        if (record[unique]) {
          return { [unique]: record[unique] }
        }
      }
    }
  }

  return {
    async finder(
      table: string,
      {
        where = {},
        distinct,
        orderBy,
        limit,
        offset,
        select = { '*': true },
      }: any = {}
    ) {
      // Process where condition
      let Kx = trx($Att[table].dbName)
      if (typeof limit === 'number') Kx = Kx.limit(limit)
      if (typeof offset === 'number') Kx = Kx.offset(offset)
      if (typeof orderBy === 'object') {
        orderBy = Array.isArray(orderBy) ? orderBy : [orderBy]
        Kx = Kx.orderBy(
          orderBy.map((obj: { [s: string]: unknown } | ArrayLike<unknown>) => {
            const [[k, v]] = Object.entries(obj)
            return { column: k, order: v }
          })
        )
      }
      if (distinct)
        Kx = Kx.distinct(
          Array.isArray(distinct) ? distinct.toString() : distinct
        )

      const wKnex = trxWhere(Kx, table, where)
      const AttCols = $Att[table].columns
      sql.push(wKnex.select('*').toString())
      let result = await wKnex.select('*')
      // Process incoming parameters
      if (Object.keys(select).length) {
        const [scalarCols, relationCols] = Object.keys(select).reduce(
          (_: any, v: string) => {
            if (typeof select[v] === 'object') _[1][v] = select[v]
            else if (select[v] === true) _[0][v] = v
            return _
          },
          [{}, {}]
        )

        for (const key in relationCols) {
          const where:any = relationCols[key].where ?? {}
          let pKeys: any, fKeys: any, relIds

          switch (AttCols[key].relation.kind) {
            case 'primary':
              const rel =
                $Att[AttCols[key].type].columns[AttCols[key].relation.relColumn]
                  .relation
              pKeys = rel.references
              fKeys = rel.keys
              where[fKeys] = {
                in: result.map((v: { [x: string]: any }) => pKeys.map((v2: string | number) => v[v2])),
              }
              break
            case 'foreign':
              pKeys = AttCols[key].relation.references
              fKeys = AttCols[key].relation.keys
              where[pKeys] = {
                in: result.map((v: { [x: string]: any }) => fKeys.map((v2: string | number) => v[v2])),
              }
              break
            case 'many':
              const id = $Att[$Att[table].columns[key].type].id
              const tableId = $Att[table].id.map(
                (v2: any) => `${$Att[table].dbName}_${v2}`
              )
              relIds = await trxQuery(
                trx($Att[table].columns[key].relation.mapTable)
                  .select()
                  .whereIn(
                    tableId,
                    result.map((v: { [x: string]: any }) => $Att[table].id.map((v2: string | number) => v[v2]))
                  )
              )
              where[id] = {
                in: relIds.map((v: { [x: string]: any }) =>
                  id
                    .map((v2: any) =>
                      Object.values({
                        [v2]: v[
                          `${$Att[$Att[table].columns[key].type].dbName}_${v2}`
                        ],
                      })
                    )
                    .flat()
                ),
              }
              break
          }
          const relationResult = await this.finder(AttCols[key].type, {
            where,
            select: select[key],
          })

          for (const v of result) {
            switch (AttCols[key].relation.kind) {
              case 'primary':
              case 'foreign':
                v[key] = relationResult.filter(
                  (r: { [x: string]: string }) =>
                    `${(AttCols[key].relation.kind === 'primary'
                      ? fKeys
                      : pKeys
                    )
                      .map((v2: string | number) => (r[v2] ? r[v2].trim() : null))
                      .join('_')}` ===
                    `${(AttCols[key].relation.kind === 'primary'
                      ? pKeys
                      : fKeys
                    )
                      .map((v2: string | number) => (v[v2] ? v[v2].trim() : null))
                      .join('_')}`
                )
                if (
                  AttCols[key].relation.toOne ||
                  AttCols[key].relation.kind === 'foreign'
                )
                  v[key] = v[key][0] || null
                break
              case 'many':
                const id = $Att[$Att[table].columns[key].type].id
                const tableId = $Att[table].id.map(
                  (v2: any) => `${$Att[table].dbName}_${v2}`
                )
                const mapTableData = relIds
                  .filter(
                    (r: { [x: string]: string }) =>
                      tableId
                        .map((v2: string | number) => (r[v2] ? r[v2].trim() : null))
                        .join('_') ==
                      $Att[table].id
                        .map((v2: string | number) => (v[v2] ? v[v2].trim() : null))
                        .join('_')
                  )
                  .map((v3: { [x: string]: string }) =>
                    id
                      .map((v2: any) =>
                        v3[
                          `${$Att[$Att[table].columns[key].type].dbName}_${v2}`
                        ]
                          ? v3[
                              `${
                                $Att[$Att[table].columns[key].type].dbName
                              }_${v2}`
                            ].trim()
                          : null
                      )
                      .join('_')
                  )
                v[key] = relationResult.filter((r: { [x: string]: string }) =>
                  mapTableData.includes(
                    id.map((v2: string | number) => (r[v2] ? r[v2].trim() : null)).join('_')
                  )
                )
            }
            v[key] =
              v[key] &&
              $RtnSelect(
                AttCols[key].type,
                v[key],
                typeof relationCols[key].select === 'object'
                  ? relationCols[key].select
                  : relationCols[key]
              )
          }
        }
      }

      return result
    },

    async insert(table: string, args: any) {
      let scalarRtn: Array<any>

      if (Array.isArray(args.data)) {
        // is an array, filter each record in the array, and seperate out if there is a relational field
        const [scalarRecords, relationRecords] = args.data.reduce(
          (_: any, v: any) => {
            let truth = true
            for (const col in v) {
              if ($Att[table].columns[col]?.relation) {
                _[1].push(v)
                truth = false
                break
              }
            }
            if (truth) _[0].push(v)
            return _
          },
          [[], []]
        )
        // Create pure scalar record
        if (scalarRecords.length) {
          scalarRtn = await trxQuery(
            trx($Att[table].dbName)
              .insert(
                argsValidate(table, dbCols(table, scalarRecords), 'insert')
              )
              .returning(args.select ? Object.keys(args.select) : '*')
          )
        } else {
          scalarRtn = []
        }

        if (relationRecords.length) {
          for (const record of relationRecords) {
            scalarRtn = scalarRtn.concat(
              await this.insert(table, {
                data: record,
                select: args.select,
              })
            )
          }
        }

        return scalarRtn
      } else {
        // is single record, seperate out scalar fields, relational(primary key table, foreign key table, many-to-many table) fields
        const [scalarCols, primaryCols, foreignCols, manyCols] = splitCols(
          table,
          args.data
        )

        // When there is a foreign key field, create its primary key table and get tje foreign key value
        if (Object.keys(foreignCols).length) {
          const relColumns: any = Object.entries(foreignCols)
          // If there exists a foreign key field, you must create a primary key table to obtain the referenced field value
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            if (v.connect && v.insert) {
              // Find if the connection exists
              let pTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connect))
                  .select('*')
              )

              ;[pTable] = pTable.length
                ? pTable
                : await this.insert(AttCol.type, {
                    data: v.insert,
                  })

              for (let i = 0; i < keys.length; i++)
                scalarCols[keys[i]] = pTable[references[i]]
            } else if (v.connect) {
              // Find the connection
              let [pTable] = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(dbCols(AttCol.type, v.connect))
                  .select('*')
              )
              if (!pTable)
                throw `table found "${
                  $Att[AttCol.type].dbName
                }" record "${JSON.stringify(v.connect)}" does not exist`

              for (let i = 0; i < keys.length; i++)
                scalarCols[keys[i]] = pTable[references[i]]
            } else if (v.insert) {
              let [pTable] = await this.insert(AttCol.type, {
                data: v['insert'],
              })

              for (let i = 0; i < keys.length; i++)
                scalarCols[keys[i]] = pTable[references[i]]
            }
          }
        }
        // Create this table and get the uniqur field for foreign key table to use
        scalarRtn = await trxQuery(
          trx($Att[table].dbName)
            .insert(argsValidate(table, dbCols(table, scalarCols), 'insert'))
            .returning(args.select ? Object.keys(args.select) : '*')
        )
        // Create all foreign key tables and apply the unique key of this table to the corresponding table
        if (Object.keys(primaryCols).length) {
          const relColumns: any = Object.entries(primaryCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            const { references, keys } = AttCol.relation
            const relationForeign: any = {}
            for (let i = 0; i < keys.length; i++)
              relationForeign[keys[i]] = scalarRtn[0][references[i]]
            // ont-to-one relationship
            if (AttCol.relation?.toOne) {
              if (v.connect && v.insert) {
                let rTable = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connect))
                    .update(relationForeign)
                    .returning('*')
                )
                if (!rTable.length)
                  await this.insert(AttCol.type, {
                    ...v.insert,
                    ...relationForeign,
                  })
              } else if (v.connect) {
                await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(dbCols(AttCol.type, v.connect))
                    .update(relationForeign)
                    .returning('*')
                )
              } else if (v.insert) {
                await this.insert(AttCol.type, {
                  data: { ...v.insert, ...relationForeign },
                })
              }
            } else {
              // one-to-many relationship
              if (v.connect) {
                if (!Array.isArray(v.connect)) v.connect = [v.connect]
                await trxQuery(
                  trx.raw(
                    v.connect
                      .reduce(
                        (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                        trx($Att[AttCol.type].dbName).update(relationForeign)
                      )
                      .toString()
                  )
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: Array.isArray(v.insert)
                    ? v.insert.map((val: any) => ({ ...val, ...relationForeign }))
                    : { ...v.insert, ...relationForeign },
                })
              }
            }
          }
        }
        // Create many-to-many relational field
        if (Object.keys(manyCols).length) {
          // Mapping table id
          const mapTabelId = $Att[table].id.reduce(
            (_: any, v: string | number) => (
              (_[`${$Att[table].dbName}_${v}`] = scalarRtn[0][v]), _
            ),
            {}
          )
          const relColumns: any = Object.entries(manyCols)
          for (const [k, v] of relColumns) {
            const AttCol = $Att[table].columns[k]
            // id of this table
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              // Query the id of each record in the relational table
              for (const item of items) {
                let [relMapTableId] = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(item)
                    .select($Att[AttCol.type].id)
                )

                relMapTableId = Object.keys(relMapTableId).reduce(
                  (_:any, v) => (
                    (_[`${$Att[AttCol.type].dbName}_${v}`] = relMapTableId[v]),
                    _
                  ),
                  {}
                )
                // upsert data to the mapping table
                const mapRecord = { ...mapTabelId, ...relMapTableId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              const ret = await this.insert(AttCol.type, {
                data: v.insert,
                select: $ArrayTrue($Att[AttCol.type].id),
              })
              let relMapTableIds = ret.map((record) =>
                Object.keys(record).reduce(
                  (_:any, v) => (
                    (_[`${$Att[AttCol.type].dbName}_${v}`] = record[v]), _
                  ),
                  {}
                )
              )

              await trxQuery(
                trx(AttCol.relation.mapTable).insert(
                  relMapTableIds.map((v) => ({
                    ...mapTabelId,
                    ...v,
                  }))
                )
              )
            }
          }
        }

        return scalarRtn
      }
    },

    async upsert(table: string, args: any) {
      const contained = await trxQuery(
        trx($Att[table].dbName).where(args.where).select('*')
      )

      return contained.length
        ? args.update
          ? await this.update(table, {
              where: args.where,
              data: args.update,
              select: args.select,
            })
          : await this.finder(table, {
              where: args.where,
              select: args.select,
            })
        : await this.insert(table, {
            data: args.insert,
            select: args.select,
          })
    },

    async update(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length)
        throw `where cannot be empty`
      // Find the record and return if not exist
      if (!args.data)
        throw `Modified table "${table}" does not have incoming data`
      const trxTmp = await trxQuery(
        trx($Att[table].dbName).where(args.where).select('*')
      )
      if (!trxTmp.length)
        throw `table "${$Att[table].dbName}" has no record for the condition: "${args.where}"`

      const [scalarColumns, primaryColumns, foreignColumns, manyColumns] =
        splitCols(table, args.data)

      if (Object.keys(foreignColumns).length) {
        const relColumns: any = Object.entries(foreignColumns)

        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          // Use foreign keys as where condition
          let foreignWhere: any = {},
            currTable: any
          for (let i = 0; i < references.length; i++) {
            foreignWhere[references[i]] =
              args.where[keys[i]] ||
              (!currTable && ([currTable] = trxTmp), currTable[keys[i]])
          }
          if (v.connect && v.insert) {
            // Find if the connection exists
            let pTable = await trxQuery(
              trx($Att[AttCol.type].dbName).where(v.connect).select('*')
            )

            ;[pTable] = pTable.length
              ? pTable
              : await this.insert(AttCol.type, {
                  data: v.insert,
                })

            for (let i = 0; i < keys.length; i++)
              scalarColumns[keys[i]] = pTable[references[i]]
          } else if (v.connect) {
            // Find the connection
            let [pTable] = await trxQuery(
              trx($Att[AttCol.type].dbName).where(v.connect).select('*')
            )

            if (!pTable)
              throw `query table "${
                $Att[AttCol.type].dbName
              }" record "${JSON.stringify(v.connect)}" does not exist`
            for (let i = 0; i < keys.length; i++)
              scalarColumns[keys[i]] = pTable[references[i]]
          } else if (v.insert) {
            let [pTable] = await this.insert(AttCol.type, {
              data: v['insert'],
            })

            for (let i = 0; i < keys.length; i++)
              scalarColumns[keys[i]] = pTable[references[i]]
          } else if (v.upsert) {
            await this.upsert(AttCol.type, v.upsert)
          } else if (v.update) {
            await this.update(AttCol.type, {
              where: foreignWhere,
              data: v.update,
            })
          } else if (v.delete === true) {
            await trxQuery(
              trx($Att[AttCol.type].dbName).where(foreignWhere).del()
            )
          } else if (v.disconnect === true) {
            await trxQuery(
              trx($Att[table].dbName)
                .where(args.where)
                .update(
                  keys.reduce((_: any, v: string) => ((_[v] = null), _), {})
                )
            )
          }
        }
      }

      // Modify this table
      let tableRtn
      if (Object.keys(scalarColumns).length) {
        const trxTmp = await trxQuery(
          trx($Att[table].dbName)
            .where(args?.where)
            .update(argsValidate(table, dbCols(table, scalarColumns), 'update'))
            .returning(args.select ? Object.keys(args.select) : '*')
        )
        tableRtn = trxTmp
      } else {
        tableRtn = await trxWhere(
          trx($Att[table].dbName).select(
            args.select ? Object.keys(args.select) : '*'
          ),
          table,
          args?.where
        )
      }

      if (Object.keys(primaryColumns).length) {
        const relColumns: any = Object.entries(primaryColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          const { references, keys } = AttCol.relation
          const relationForeign: any = {}
          for (let i = 0; i < keys.length; i++)
            relationForeign[keys[i]] = tableRtn[0][references[i]]
          if (AttCol.relation?.toOne) {
            if (v.connect && v.insert) {
              let rTable = await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(v.connect)
                  .update(relationForeign)
                  .returning('*')
              )

              if (!rTable.length) await this.insert(AttCol.type, v)
            } else if (v.connect) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(v.connect)
                  .update(relationForeign)
                  .returning('*')
              )
            } else if (v.insert) {
              await this.insert(AttCol.type, { data: v.insert })
            } else if (v.upsert) {
              await this.upsert(AttCol.type, v.upsert)
            } else if (v.update) {
              await this.update(AttCol.type, {
                where: relationForeign,
                data: v.update,
              })
            } else if (v.delete) {
              await trxQuery(
                trx($Att[AttCol.type].dbName).where(relationForeign).del()
              )
            } else if (v.disconnect) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(relationForeign)
                  .update(
                    keys.reduce((_: any, v: any) => ((_[v] = null), _), {})
                  )
              )
            }
          } else {
            // one-to-many relationship
            if (v.set) {
              await trxQuery(
                trx($Att[AttCol.type].dbName)
                  .where(relationForeign)
                  .update(
                    keys.reduce((_: any, v: any) => ((_[v] = null), _), {})
                  )
              )
              if (!Array.isArray(v.set)) v.set = [v.set]
              await trxQuery(
                trx.raw(
                  v.set
                    .reduce(
                      (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                      trx($Att[AttCol.type].dbName).update(relationForeign)
                    )
                    .toString()
                )
              )
            } else {
              if (v.connect) {
                if (!Array.isArray(v.connect)) v.connect = [v.connect]
                await trxQuery(
                  trx.raw(
                    v.connect
                      .reduce(
                        (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                        trx($Att[AttCol.type].dbName).update(relationForeign)
                      )
                      .toString()
                  )
                )
              }
              if (v.insert) {
                await this.insert(AttCol.type, {
                  data: Array.isArray(v.insert)
                    ? v.insert.map((val: any) => ({ ...val, ...relationForeign }))
                    : { ...v.insert, ...relationForeign },
                })
              }
              if (v.upsert) {
                if (!Array.isArray(v.upsert)) v.upsert = [v.upsert]
                for (const val of v.upsert) {
                  await this.upsert(AttCol.type, {
                    where: val.where,
                    update: val.update,
                    insert: { ...val.insert, ...relationForeign },
                  })
                }
              }
              if (v.update) {
                if (!Array.isArray(v.update)) v.update = [v.update]
                for (const val of v.update) {
                  await this.update(AttCol.type, {
                    where: {
                      ...val.where,
                      ...relationForeign,
                    },
                    data: val.data,
                  })
                }
              }
              if (v.updateMany) {
                await trxWhere(
                  trx($Att[AttCol.type].dbName).update(v.updateMany.data),
                  AttCol.type,
                  {
                    ...v.updateMany.where,
                    ...relationForeign,
                  }
                )
              }
              if (v.delete) {
                if (!Array.isArray(v.delete)) v.delete = [v.delete]
                for (const val of v.delete) {
                  await trxQuery(
                    trx.raw(
                      trxWhere(
                        trx($Att[AttCol.type].dbName).del(),
                        AttCol.type,
                        {
                          ...val,
                          ...relationForeign,
                        }
                      ).toString()
                    )
                  )
                }
              }
              if (v.deleteMany) {
                await trxWhere(
                  trx($Att[AttCol.type].dbName).del(),
                  AttCol.type,
                  {
                    ...v.deleteMany,
                    ...relationForeign,
                  }
                )
              }
              if (v.disconnect) {
                await trxQuery(
                  trx.raw(
                    trxWhere(
                      v.disconnect.reduce(
                        (_: any, v: any) => trxWhere(_, AttCol.type, v, 'OR'),
                        trx($Att[AttCol.type].dbName).update(
                          keys.reduce(
                            (_: any, v: any) => ((_[v] = null), _),
                            {}
                          )
                        )
                      ),
                      AttCol.type,
                      relationForeign
                    ).toString()
                  )
                )
              }
            }
          }
        }
      }
      // many-to-many relationship
      if (Object.keys(manyColumns).length) {
        const relColumns: any = Object.entries(manyColumns)
        for (const [k, v] of relColumns) {
          const AttCol = $Att[table].columns[k]
          // this table id
          let tableId
          if (args.where[$Att[table].id.join('_')]) {
            tableId = args.where
          } else {
            tableId = (
              await trxQuery(
                trx($Att[table].dbName).where(args.where).select($Att[table].id)
              )
            )[0]
          }
          // id of mapping table
          let mapTableId: any = {}
          for (const k in tableId) {
            mapTableId[`${$Att[table].dbName}_${k}`] = tableId[k]
          }
          // ids of relational tables
          const trxTmp = await trxQuery(
            trx(AttCol.relation.mapTable).where(mapTableId).select('*')
          )
          const relTableIds = trxTmp.map((v: { [x: string]: any }) => {
            $Att[AttCol.type].id.reduce(
              (_: { [x: string]: any }, v2: string | number) => ((_[v2] = v[`${$Att[AttCol.type].dbName}_${v2}`]), _),
              {}
            )
          })

          if (v.set) {
            const updateSet = async (record: { [x: string]: any }) => {
              // If the record has only 1 item, is unique, and the relational table has other required fields, it is considered to be connect
              // If the record has only 1 item, is unique, and the relational table does not havr other required fields, it is considered to be upsert
              if (
                Object.keys(record).length === 1 &&
                $Att[AttCol.type].uniques.some(
                  (v: any[]) => record[Array.isArray(v) ? v.join('_') : v]
                )
              ) {
                const columns = $Att[AttCol.type].columns
                let requiredItem = []
                $Att[AttCol.type].uniques.some((v: any) => {
                  const items = Array.isArray(v) ? v : [v]
                  if (record[items.join('_')]) {
                    requiredItem = Object.keys(columns).filter((v) =>
                      items.includes(v)
                        ? false
                        : 'required' === columns[v].optional
                    )
                    return true
                  } else return false
                })

                return requiredItem.length
                  ? await trxWhere(
                      trx($Att[AttCol.type].dbName).select(
                        $Att[AttCol.type].id
                      ),
                      AttCol.type,
                      record
                    )
                  : // There is no required field, it may be a connection or a creation, you need to use upsert
                    await trxQuery(
                      trx($Att[AttCol.type].dbName)
                        .insert(argsValidate(AttCol.type, record, 'insert'))
                        .onConflict(Object.keys(record))
                        .ignore()
                        .returning($Att[AttCol.type].id)
                    )
              }
              // is to creat
              else
                return await this.insert(AttCol.type, {
                  data: record,
                })
            }

            let relTableId: any[] = []
            const items = Array.isArray(v.set) ? v.set : [v.set]
            for (const item of items)
              relTableId = relTableId.concat(await updateSet(item))

            // Delete the old relationships in the mapping table and store the new relationships
            await trxQuery(
              trx(AttCol.relation.mapTable).where(mapTableId).del()
            )

            await trxQuery(
              trx(AttCol.relation.mapTable).insert(
                relTableId.map((v2) =>
                  Object.assign(
                    Object.keys(v2).reduce(
                      (_:any, v3) => ((_[`${AttCol.type}_${v3}`] = v2[v3]), _),
                      {}
                    ),
                    mapTableId
                  )
                )
              )
            )
          } else {
            let ids: any[] = []
            if (v.connect) {
              const items = Array.isArray(v.connect) ? v.connect : [v.connect]
              for (const v of items) {
                let [relId] = await trxQuery(
                  trx($Att[AttCol.type].dbName)
                    .where(v)
                    .select($Att[AttCol.type].id)
                )
                relId = Object.keys(relId).reduce(
                  (_:any, v) => (
                    (_[`${$Att[AttCol.type].dbName}_${v}`] = relId[v]), _
                  ),
                  {}
                )
                const mapRecord = { ...mapTableId, ...relId }
                await trxQuery(
                  trx(AttCol.relation.mapTable)
                    .insert(mapRecord)
                    .onConflict(Object.keys(mapRecord))
                    .ignore()
                )
              }
            }
            if (v.insert) {
              // There may be a problem---------------------------------------------------------------------------------
              const updateInsert = async (record: any) =>
                await this.upsert(AttCol.type, {
                  where: recordUnique(AttCol.type, record),
                  insert: record,
                })

              if (Array.isArray(v.insert)) {
                for (const record of v.insert)
                  ids = ids.concat(await updateInsert(record))
              } else ids = await updateInsert(v.insert)

              await trxQuery(
                trx(AttCol.relation.mapTable).insert(
                  ids.map((v2: { [x: string]: any }) =>
                    Object.keys(v2).reduce(
                      (_, v3) => ((_[`${k}_${v3}`] = v2[v3]), _),
                      mapTableId
                    )
                  )
                )
              )
            }
            if (v.upsert) {
              const items = Array.isArray(v.upsert) ? v.upsert : [v.upsert]
              for (const item of items) {
                await this.upsert(AttCol.type, item)
              }
            }
            if (v.update) {
              const items = Array.isArray(v.update) ? v.update : [v.update]
              for (const item of items) {
                await this.update(AttCol.type, item)
              }
            }
            if (v.updateMany) {
              const where = trxWhere(
                trx($Att[AttCol.type].dbName).update(v.updateMany.data),
                AttCol.type,
                v.updateMany.where
              )

              await trxWhere(where, AttCol.type, {
                [$Att[AttCol.type].id]: '',
              })
            }
            if (v.delete) {
              const items = Array.isArray(v.delete) ? v.delete : [v.delete]
              await items.reduce(
                (_: any, v: { where: any }) => trxWhere(_, AttCol.type, v.where, 'OR'),
                trx($Att[AttCol.type].dbName).del()
              )
              // Delete the corresponding records in the mapping table (subsequent improvement)
            }
            if (v.deleteMany) {
              const where = trxWhere(
                trx($Att[AttCol.type].dbName).del(),
                AttCol.type,
                v.deleteMany.where
              )

              await trxWhere(where, AttCol.type, {
                [$Att[AttCol.type].id]: {
                  in: relTableIds.map((v: any) => Object.values(v)),
                },
              })
            }
            if (v.disconnect) {
              const items = Array.isArray(v.disconnect)
                ? v.disconnect
                : [v.disconnect]
              const relMapIds = []
              for (const v2 of items) {
                const [relRecId] = await trxQuery(
                  trx($Att[AttCol.type].dbName).where(
                    v2.select($Att[AttCol.type].id)
                  )
                )

                relMapIds.push(
                  Object.keys(relRecId).reduce(
                    (_:any, v3) => (
                      (_[`${$Att[AttCol.type].dbName}_${v3}`] = relRecId[v3]), _
                    ),
                    {}
                  )
                )
              }

              await relMapIds.reduce(
                (_, v4) =>
                  trxWhere(_, AttCol.type, { ...mapTableId, ...v4 }, 'OR'),
                trx($Att[AttCol.type].dbName).del()
              )
            }
          }
        }
      }

      return tableRtn
    },

    async updateMany(table: string, args: any) {
      return (
        await trx.raw(
          trxWhere(
            updateOperator(table, args.data).returning(
              args.select ? Object.keys(args.select) : '*'
            ),
            table,
            args?.where
          ).toString()
        )
      ).rows
    },

    async delete(table: string, args: any) {
      if (!args.where || !Object.keys(args.where).length)
        throw `where cannot be empty`
      return await trxWhere(
        trx($Att[table].dbName)
          .del()
          .returning(args.select ? Object.keys(args.select) : '*'),
        table,
        args.where
      )
    },

    async deleteMany(table: string, args: any) {
      return await trxWhere(
        trx($Att[table].dbName)
          .del()
          .returning(args?.select ? Object.keys(args.select) : '*'),
        table,
        args?.where
      )
    },

    async aggregate(table: string, query: $AggregateQuery, args: any) {
      if (!args?.select || args.select === '*')
        (<any>args).select = { count: '*' }

      return await trxWhere(
        trx($Att[table].dbName)[query](args.select),
        table,
        args?.where
      )
    },
  }
}